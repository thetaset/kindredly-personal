var Es=Object.defineProperty;var bs=(r,e,t)=>e in r?Es(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var A=(r,e,t)=>bs(r,typeof e!="symbol"?e+"":e,t);import{d as y,b as z,c as W,k as E,W as M,X as Zt,Y as Oe,U as Y,Z as Ct,$ as pe,a0 as It,a1 as Rs,a2 as Us,a3 as As,v as Rt,a4 as dt,a5 as Cs,a6 as Ds,a7 as vs,a8 as _s,a9 as Ls,aa as Ms,ab as Os,l as kt,ac as pt,ad as Ge,ae as tt,af as Ps}from"./components.globalBic2x0kT.js";import{_ as Ws}from"./@capacitorCjBcbZvA.js";import{S as es,I as Pe,B as Ns,s as Fs,g as ts}from"./browserTabsB3WsZHRs.js";import{I as ss}from"./IDBStoreobYAVGyT.js";import{g as qs,s as Ae,f as yt,t as Dt,a as Bs}from"./usageBVbzi9Go.js";import{v as js}from"./uuidCtRu48qb.js";import{l as zs,a as Hs}from"./cheerioB5KhtkHh.js";import{g as Gs}from"./ai_lookup_utilszDX_hcwM.js";import"./@vueC3Nhqlrl.js";import"./vue3-toastifyDll2FbVh.js";import"./bootstrap-vue-nextDnMzdrWQ.js";import"./domutilsDoyZNJC1.js";import"./dom-serializerDa3BHheJ.js";import"./domelementtypeCGHdmTnT.js";import"./entitiesL-JVAG0g.js";import"./domhandlerCjB8Dp5l.js";import"./cheerio-selectCi_KMQs6.js";import"./css-selectB-mTe8M1.js";import"./boolbaseFcE-Bo6-.js";import"./@mozillaCDB2aYYy.js";import"./css-whatBWHXJlxz.js";import"./nth-checkCZz2Bb-9.js";import"./parse5DyBihX4n.js";import"./parse5-htmlparser2-tree-adapterDcYntZqB.js";import"./htmlparser2BedvqtWw.js";async function Ut(r,e={}){y("FETCHING",r);const{timeout:t=8e3}=e,s=new AbortController,n=setTimeout(()=>s.abort(),t),a=await fetch(r,{...e,signal:s.signal});return clearTimeout(n),a}let q;try{q=crypto}catch{console.log("crypto not available, trying to import crypto module"),typeof window<"u"&&window.crypto?q=window.crypto:Ws(()=>import("./__vite-browser-externalBIHI7g3E.js"),[]).then(e=>{q=e})}const Ee=class Ee{static getInstance(){return Ee.instance||(Ee.instance=new TextEncoder),Ee.instance}};A(Ee,"instance");let st=Ee,Ce=q;class h{static randomUUID(){if(!Ce)throw new Error("KM: WebCrypto not available");return Ce.randomUUID()}static ab2strLim(e){const t=String.fromCharCode(...new Uint8Array(e));return btoa(t)}static ab2str(e){const t=new Uint8Array(e);let s="";for(let n=0;n<t.length;n++)s+=String.fromCharCode(t[n]);return btoa(s)}static ab2strPlain(e){return String.fromCharCode(...new Uint8Array(e))}static str2abx(e){const t=new ArrayBuffer(e.length);return new Uint8Array(t).set(new Uint8Array(e.split("").map(n=>n.charCodeAt(0)))),t}static str2ab(e){const t=atob(e),s=t.length,n=new Uint8Array(s);for(let a=0;a<s;a++)n[a]=t.charCodeAt(a);return n.buffer}static str2abV0(e){for(var t=new ArrayBuffer(e.length),s=new Uint8Array(t),n=0,a=e.length;n<a;n++)s[n]=e.charCodeAt(n);return t}static ab2strUTF(e){return new TextDecoder("utf-8").decode(new Uint8Array(e))}static str2abUTF(e){return new TextEncoder().encode(e).buffer}static ab2base64(e){const t=String.fromCharCode(...new Uint8Array(e));return btoa(t)}static base642ab(e){const t=atob(e),s=t.length,n=new Uint8Array(s);for(let a=0;a<s;a++)n[a]=t.charCodeAt(a);return n.buffer}static base64ToBytes(e){const t=atob(e);return Uint8Array.from(t,s=>s.codePointAt(0))}static bytesToBase64(e){const t=String.fromCodePoint(...e);return btoa(t)}static ab2base64_x(e){return h.bytesToBase64(new Uint8Array(e))}static base642ab_x(e){return h.base64ToBytes(e).buffer}static ab2base64_NA(e){let t="";const s=new Uint8Array(e),n=s.byteLength;for(let a=0;a<n;a++)t+=String.fromCharCode(s[a]);return btoa(t)}static base642ab_NA(e){y("Base64",e);const t=atob(e),s=t.length,n=new Uint8Array(s);for(let a=0;a<s;a++)n[a]=t.charCodeAt(a);return n.buffer}static keyFieldsToId(e){return`${e.groupType}:${e.groupId}:${e.keyType}_${e.keyName}.v${e.version}`}static getUserSecretKeyId(e){return h.keyFieldsToId({groupType:"user",groupId:e,keyType:"sym",keyName:"default",version:0})}static getRecoveryKeyId(e){return h.keyFieldsToId({groupType:"user",groupId:e,keyType:"sym",keyName:"recovery",version:0})}static getAcntSecretKeyId(e){return h.keyFieldsToId({groupType:"acnt",groupId:e,keyType:"sym",keyName:"default",version:0})}static getAcntAdminSecretKeyId(e){return h.keyFieldsToId({groupType:"acnt",groupId:e,keyType:"sym",keyName:"admin",version:0})}static getUserPublicKeyId(e){return h.keyFieldsToId({groupType:"user",groupId:e,keyType:"pub",keyName:"default",version:0})}static getAcntPublicKeyId(e){return h.keyFieldsToId({groupType:"acnt",groupId:e,keyType:"pub",keyName:"default",version:0})}static keyInfoToId(e,t=0){return e.groupType==="user"&&e.keyName==="password"?"userPassword":h.keyFieldsToId({groupType:e.groupType,groupId:e.groupId,keyType:e.keyType,keyName:e.keyName,version:t})}static invKeyInfoToId(e,t=0){return e.keyType==="pvt"?h.keyInfoToId({...e,keyType:"pub"},t):e.keyType==="pub"?h.keyInfoToId({...e,keyType:"pvt"},t):h.keyInfoToId(e,t)}static serializeAlgo(e){let t={};for(let s in e)s==="publicExpponent"?t[s]=h.ab2str(e[s]):t[s]=e[s];return t}static deserializeAlgo(e){let t={};for(let s in e)s==="publicExpponent"?t[s]=h.str2ab(e[s]):t[s]=e[s];return t}static async createSecretKey(e,t,s,n=["wrapKey","unwrapKey","encrypt","decrypt"]){const a={name:"AES-GCM",length:256},i=await Ce.subtle.generateKey(a,!0,n),o={groupType:e,groupId:t,keyType:"sym",keyName:s,keyAlgo:a,keyOps:n};return{keyId:h.keyInfoToId(o),keyInfo:o,key:i}}static async createKeyGroup(e,t){y("createKeyGroup",e,t);const s={name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},n=["encrypt","decrypt","wrapKey","unwrapKey"],{publicKey:a,privateKey:i}=await q.subtle.generateKey(s,!0,n),o={groupType:e,groupId:t,keyType:"pub",keyName:"default",keyAlgo:s,keyOps:n},c={keyId:h.keyInfoToId(o),keyInfo:o,key:a},l={groupType:e,groupId:t,keyType:"pvt",keyName:"default",keyAlgo:s,keyOps:n},u={keyId:h.keyInfoToId(l),keyInfo:l,key:i},p=await h.createSecretKey(e,t,"default");return{publicKey:c,privateKey:u,secret:p}}static async createPasswordKey(e,t,s="password"){const n=st.getInstance(),a=await Ce.subtle.importKey("raw",n.encode(e),"PBKDF2",!1,["deriveKey"]),i={name:"PBKDF2",salt:n.encode(t),iterations:1e5,hash:"SHA-256"},o={name:"AES-GCM",length:256},c=["wrapKey","unwrapKey","encrypt","decrypt"],l=await Ce.subtle.deriveKey(i,a,o,!1,c),u={groupType:"user",groupId:"default",keyType:"sym",keyName:s,keyAlgo:o,keyOps:c};return{keyId:h.keyInfoToId(u),keyInfo:u,key:l}}static async wrapKey(e,t){const s=q.getRandomValues(new Uint8Array(12)),n=await q.subtle.exportKey("jwk",e.key);y("KM: Exported key:",n);const i=st.getInstance().encode(JSON.stringify(n)),o=await q.subtle.encrypt({name:t.keyInfo.keyAlgo.name,iv:s},t.key,i);return{keyId:e.keyId,wrappingKeyId:t.keyId,unwrappingKeyId:h.invKeyInfoToId(t.keyInfo),keyInfo:e.keyInfo,iv:s,wrappedData:o,wrappingKeyGroup:t.keyInfo.groupType}}static async unwrapKey(e,t){const s={name:t.keyInfo.keyAlgo.name,iv:e.iv},n=await q.subtle.decrypt(s,t.key,e.wrappedData),a=JSON.parse(h.ab2strPlain(n)),i=a,o=await q.subtle.importKey("jwk",i,e.keyInfo.keyAlgo,!0,a.key_ops);return{keyId:e.keyId,key:o,keyInfo:e.keyInfo}}static async serializeWrappedKey(e,t){const s=h.serializeAlgo(e.keyInfo.keyAlgo),n={...e.keyInfo,keyAlgo:s};return{keyId:e.keyId,iv:h.ab2str(e.iv),data:h.ab2str(e.wrappedData),wrappingKeyId:e.wrappingKeyId,wrappingKeyGroup:e.wrappingKeyGroup,unwrappingKeyId:e.unwrappingKeyId,keyInfo:n,format:"wrapped",permission:t}}static async deserializeSerializedWrappedKey(e){const t=h.deserializeAlgo(e.keyInfo.keyAlgo),s={...e.keyInfo,keyAlgo:t};return{keyId:e.keyId,iv:h.str2ab(e.iv),wrappedData:h.str2ab(e.data),wrappingKeyId:e.wrappingKeyId,wrappingKeyGroup:e.wrappingKeyGroup,unwrappingKeyId:e.unwrappingKeyId,keyInfo:s}}static async keyEntryToWrappedKey(e){if(e.keyData==null||e.keyData.wrappedKey==null||e.keyData.iv==null||e.wrappingKeyId==null||e.wrappingKeyGroup==null||e.unwrappingKeyId==null)throw new Error("Key entry is not wrapped: "+e.keyId);const s={keyAlgo:h.deserializeAlgo(e.keyAlgo),keyType:e.keyType,keyName:e.keyName,groupId:e.groupId,groupType:e.groupType},n=h.str2ab(e.keyData.wrappedKey),a=h.str2ab(e.keyData.iv);return{keyId:e.keyId,wrappingKeyId:e.wrappingKeyId,wrappingKeyGroup:e.wrappingKeyGroup,unwrappingKeyId:e.unwrappingKeyId,keyInfo:s,iv:a,wrappedData:n}}static async keyEntryToKeyInstance(e){if(e.isWrapped)throw new Error("Key entry is wrapped");const t=h.deserializeAlgo(e.keyAlgo),s=e.keyOps||["encrypt","decrypt"],n=JSON.parse(e.keyData.data),a={keyAlgo:t,keyType:e.keyType,keyName:e.keyName,groupId:e.groupId,groupType:e.groupType,keyOps:s};y("KM: Importing key",e);const i=await q.subtle.importKey(e.keyData.format,n,t,!0,n.key_ops);return{keyId:e.keyId,key:i,keyInfo:a}}static async serializeKey(e,t="self"){const s=await q.subtle.exportKey("jwk",e.key),n=h.serializeAlgo(e.keyInfo.keyAlgo),a={...e.keyInfo,keyAlgo:n};return{keyId:e.keyId,format:"jwk",data:JSON.stringify(s),keyInfo:a,permission:t}}static async deserializeKey(e){const t=JSON.parse(e.data),s=await q.subtle.importKey("jwk",t,{name:"RSA-OAEP",hash:"SHA-256"},!0,t.key_ops);return{keyId:e.keyId,key:s,keyInfo:e.keyInfo}}static async serializedWrappedKeyToKeyEntry(e){const t={iv:e.iv,wrappedKey:e.data},s=e.keyInfo.keyAlgo;return{keyId:e.keyId,groupId:e.keyInfo.groupId,groupType:e.keyInfo.groupType,keyType:e.keyInfo.keyType,keyName:e.keyInfo.keyName,keyAlgo:s,isWrapped:!0,version:"0",keyData:t,wrappingKeyId:e.wrappingKeyId,unwrappingKeyId:e.unwrappingKeyId,wrappingKeyGroup:e.wrappingKeyGroup,keyOps:e.keyInfo.keyOps||[],permission:e.permission}}static async serializedKeyToKeyEntry(e){const t=e.keyInfo.keyAlgo;return{keyId:e.keyId,groupId:e.keyInfo.groupId,groupType:e.keyInfo.groupType,keyType:e.keyInfo.keyType,keyName:e.keyInfo.keyName,keyAlgo:t,isWrapped:!1,version:"0",keyData:{format:e.format,data:e.data},keyOps:e.keyInfo.keyOps||[],permission:e.permission}}static async serializedKeyThingToKeyEntry(e){return e.format=="wrapped"?h.serializedWrappedKeyToKeyEntry(e):h.serializedKeyToKeyEntry(e)}static async serializedKeyMapToKeyEntries(e){const t=[];for(const s of Object.values(e))s&&t.push(await h.serializedKeyThingToKeyEntry(s));return t}static async generateUserKeys(e,t,s){const n=await h.createPasswordKey(t,s),{publicKey:a,privateKey:i,secret:o}=await h.createKeyGroup("user",e),c=await h.wrapKey(o,n),l=await h.wrapKey(i,o),{recoveryKeyWrapped:u,recoverySecretWrapped:p}=await h.generateRecoveryKeys(e,o);return{passwordKey:n,publicKey:a,privateKey:i,privateKeyWrapped:l,secret:o,secretWrapped:c,recoveryKeyWrapped:u,recoverySecretWrapped:p}}static async generateRecoveryKeys(e,t){const s=await h.createSecretKey("user",e,"recovery"),n=await h.wrapKey(s,t),a=await h.wrapKey(t,s);return{recoveryKeyWrapped:n,recoverySecretWrapped:a}}static async generateUserKeysWithSecret(e,t){const{publicKey:s,privateKey:n,secret:a}=await h.createKeyGroup("user",e),i=await h.wrapKey(a,t),o=await h.wrapKey(n,a),{recoveryKeyWrapped:c,recoverySecretWrapped:l}=await h.generateRecoveryKeys(e,a);return{publicKey:s,privateKey:n,privateKeyWrapped:o,secret:a,secretWrapped:i,recoveryKeyWrapped:c,recoverySecretWrapped:l}}static async generateNewPasswordWrappedKey(e,t,s){const n=await h.createPasswordKey(e,t),a=await h.wrapKey(s,n);return{passwordKey:n,secret:s,secretWrapped:a}}static async generateAccountKeys(e){const{publicKey:t,privateKey:s,secret:n}=await h.createKeyGroup("acnt",e),a=await h.wrapKey(s,n);return{publicKey:t,privateKey:s,privateKeyWrapped:a,secret:n}}static async generateGroupKey(e,t,s,n){const a=await h.createSecretKey(e,t,s),i=await h.wrapKey(a,n);return{secret:a,secretWrapped:i}}static async generateNewAccountKeyBundleForExistingUser(e,t){y("KM: Generating account keys for existing user");const s=await h.generateAccountKeys(e),n=await h.wrapKey(s.secret,t),a={usersCopyOfAcntSecret:await h.serializeWrappedKey(n,"user")},i={acntPrivateKeyWrapped:await h.serializeWrappedKey(s.privateKeyWrapped,"user"),acntPublicKey:await h.serializeKey(s.publicKey,"public")};return{user:a,acnt:i}}static async generateUserKeyBundleForNewAccount(e,t,s,n){y("KM: Generating user keys for new account");const a=await h.generateUserKeys(e,s,n),i=await h.generateAccountKeys(t),o=await h.wrapKey(i.secret,a.secret),c={userPublicKey:await h.serializeKey(a.publicKey,"public"),userSecretWrapped:await h.serializeWrappedKey(a.secretWrapped,"self"),userPrivateKeyWrapped:await h.serializeWrappedKey(a.privateKeyWrapped,"user"),usersCopyOfAcntSecret:await h.serializeWrappedKey(o,"user"),userRecoveryKeyWrapped:await h.serializeWrappedKey(a.recoveryKeyWrapped,"user"),userRecoverySecretWrapped:await h.serializeWrappedKey(a.recoverySecretWrapped,"user")},l={acntPrivateKeyWrapped:await h.serializeWrappedKey(i.privateKeyWrapped,"user"),acntPublicKey:await h.serializeKey(i.publicKey,"public")};return{user:c,acnt:l}}static async generateUserKeyBundleWithAccountSecretKey(e,t){y("KM: Generating user keys for existing account");const s=await h.generateUserKeysWithSecret(e,t),n={userPublicKey:await h.serializeKey(s.publicKey,"public"),userPrivateKeyWrapped:await h.serializeWrappedKey(s.privateKeyWrapped,"user"),userRecoveryKeyWrapped:await h.serializeWrappedKey(s.recoveryKeyWrapped,"user"),userRecoverySecretWrapped:await h.serializeWrappedKey(s.recoverySecretWrapped,"user")},a={userSecretWrapped:await h.serializeWrappedKey(s.secretWrapped,"user")};return{user:n,acnt:a}}static async generateUserKeyBundleForExistingAccount(e,t,s,n,a,i){y("KM: Generating user keys for existing account");const o=await h.generateUserKeys(e,t,s),c=await h.wrapKey(n,o.secret),l={userPublicKey:await h.serializeKey(o.publicKey,"public"),userSecretWrapped:await h.serializeWrappedKey(o.secretWrapped,"self"),userPrivateKeyWrapped:await h.serializeWrappedKey(o.privateKeyWrapped,"user"),usersCopyOfAcntSecret:await h.serializeWrappedKey(c,"user"),userRecoveryKeyWrapped:await h.serializeWrappedKey(o.recoveryKeyWrapped,"user"),userRecoverySecretWrapped:await h.serializeWrappedKey(o.recoverySecretWrapped,"user")};if(i==="admin"){const u=await h.wrapKey(o.secret,a);l.usersCopyOfAcntAdminSecret=await h.serializeWrappedKey(u,"user")}else l.adminsCopyOfUserSecret=await h.serializeWrappedKey(await h.wrapKey(o.secret,a),"admin");return Object.values(l).forEach(u=>{if(!u)throw new Error("Key is null");y("userKeys ",u.keyId,", permission",u.permission)}),l}static async generateUserKeyBundle(e,t,s){y("KM: Generating user keys for existing account");const n=await h.generateUserKeys(e,t,s);return{userPublicKey:await h.serializeKey(n.publicKey,"public"),userSecretWrapped:await h.serializeWrappedKey(n.secretWrapped,"self"),userPrivateKeyWrapped:await h.serializeWrappedKey(n.privateKeyWrapped,"user"),userRecoveryKeyWrapped:await h.serializeWrappedKey(n.recoveryKeyWrapped,"user"),userRecoverySecretWrapped:await h.serializeWrappedKey(n.recoverySecretWrapped,"user")}}static async hashPassword(e,t){const n=new TextEncoder().encode(e+t),a=await q.subtle.digest("SHA-256",n);return Array.from(new Uint8Array(a)).map(c=>c.toString(16).padStart(2,"0")).join("")}}const vt="kindredClientId";let ge=null;async function ns(){return ge||(ge=await z(vt),ge||(ge="CLID_"+await h.randomUUID(),await W(vt,ge)),ge)}async function ht(){const r=await ns(),e=E.clientVersion,t=E.appId,s=E.appVersion,n=E.appType;return{clientId:r,clientVersion:e,appId:t,appVersion:s,appType:n}}const Ke="conn",Vs="network_usage";class H{static async reset(){await Oe(Vs),await Oe(Ke)}static async isActive(){const e=await H.getAuthInfo();return!!(e!=null&&e.user)}static async getCurrentUser(){const e=await H.getAuthInfo();return e==null?void 0:e.user}static async updateUserObj(e){let t=await z(Ke);return t.user=e,await W(Ke,t),t}static async updateAuthInfo(e){let t={user:e==null?void 0:e.user,tokenData:e==null?void 0:e.tokenData,lastUpdated:new Date,success:e==null?void 0:e.success};return await W(Ke,t),t}static async getAuthInfo(){let e=await z(Ke);if(!e){let t={tokenData:void 0,user:void 0,lastUpdated:null,success:!1};await W(Ke,t),e=t}return e}}class k{static async remoteRequestRaw(e,t={},s={},n={}){var g,w;const a=(s==null?void 0:s.method)||"POST";if((s==null?void 0:s.needAuth)===!0&&!await H.isActive())throw console.error("Not Authenticated, not sending request:",e),new M("Not Authenticated, not sending request",401);const o=await H.getAuthInfo(),c=await Zt(),l=!!((g=o==null?void 0:o.tokenData)!=null&&g.token);y("Making Request (remote)",e,a,t,`AuthRequired=${l}`);const u={"Content-Type":"application/json",API_VERSION:E.apiVersion,tsclientid:await ns()};l&&(u.authorization=`Bearer ${(w=o==null?void 0:o.tokenData)==null?void 0:w.token}`);const p=a=="POST"?JSON.stringify(t):void 0;let d=0;p&&(d=p.length*2+e.length*2);const f=await Ut(`${c.apiURL}${e}`,{method:a,mode:"cors",cache:"no-cache",credentials:"include",headers:u,redirect:"follow",referrerPolicy:"no-referrer",body:p,timeout:6e4,...n});return f.dataSentSize=d,f}static async remoteRequest(e,t={},s={},n={}){const a=new Date().getTime(),i=await this.remoteRequestRaw(e,t,s,n).then(async c=>{if(c.status==401)return y("401 data",e,c.body),{success:!1,message:"Unauthenticated",errorType:"AUTH",status:c.status};if(c.status==403)return y("403 data",e,c.body),{success:!1,message:"Access Denied",errorType:"AUTH",status:c.status};try{return await c.json()}catch(l){return{success:!1,message:"Failed to parse json response for "+e,errorType:"MALFORMED",details:{e:l},status:500}}}).catch(c=>{if(y("Response status",c.status),c instanceof TypeError&&c.message.includes("Failed to fetch")){const l=`Failed to connect to server. <a target="blank" href='https://kindredly.ai/status'>Click here</a> to check Kindredly.ai's system status.`;return console.error(l,e,c),{success:!1,message:l,errorType:"CONNECTION_FAILED",details:{e:c},status:500}}else{if(c instanceof SyntaxError&&c.message.includes("Unexpected token < in JSON"))return{success:!1,message:"API response error for "+e};if(c.message.includes("The user aborted a request"))return{success:!1,message:"Server timeout, please try again later",errorType:"TIMEOUT",details:{e:c},status:500};if(console.error("Unknown error:xx",e,c),c!=null&&c.message&&c.message.includes("NetworkError")){const l=`Failed to connect to server. <a target="blank" href='https://thetaset.com/status'>Click here</a> to check ThetaSet's system status.`;return console.error(l,c),{success:!1,message:l,errorType:"CONNECTION_FAILED",details:{e:c},status:500}}return{success:!1,message:c.message,errorType:"UNKNOWN",details:{e:c},status:500}}}),o=new Date().getTime()-a;{let c=JSON.stringify(i),l=JSON.parse(c);y(`Request result (Remote) ${o} ms  `,e,l)}if(i.success)return i.results;throw console.error("ERROR:",e,i.message),new M(i.message,i.status,i.details,i.errorType)}}class nt{constructor(e,t=null){A(this,"user");A(this,"currentUser");this.currentUser=e,this.user=t||e}get currentUserId(){var e;return(e=this.currentUser)==null?void 0:e._id}get isCurrentUser(){return this.currentUserId===this.userId}get userId(){return this.user._id}get accountId(){return this.user.accountId}}class ee{constructor(e,t,s,n=[],a=new Map){A(this,"userId");A(this,"accountId");A(this,"userSecret");A(this,"keyEntryList");A(this,"keyInstanceMap");A(this,"encoder",new TextEncoder);A(this,"decoder",new TextDecoder);this.userId=e,this.accountId=t,this.userSecret=s;const i=h.getUserSecretKeyId(e);this.keyEntryList=n.filter(o=>o.wrappingKeyId!="userPassword"&&o.keyId!=i),this.keyInstanceMap=a}static async instanceFromPassword(e,t,s,n,a){y("KM: Creating key manager from password");const i=await h.createPasswordKey(s,n);return ee._instanceFromKey(e,t,i,a)}static async instanceFromAdminKey(e,t,s,n){return y("KM: Creating key manager admin key"),ee._instanceFromKey(e,t,s,n)}static async _instanceFromKey(e,t,s,n){y("KM: Creating key manager",e,t,s,n);const a=h.getUserSecretKeyId(e),i=n.find(l=>l.keyId===a&&l.wrappingKeyId==="userPassword");if(!i)throw new Error("No user secret key entry found:"+e);y("KM: Unwrapping user secret",i);const o=await h.keyEntryToWrappedKey(i),c=await h.unwrapKey(o,s);return new ee(e,t,c,n)}static async instanceFromSerialized(e){const{userId:t,accountId:s,userSecret:n,keyEntries:a}=e,i=await h.deserializeKey(n);return new ee(t,s,i,a)}static async emptyInstance(e,t){return new ee(e,t,null,null)}static async instanceFromRecoveryKey(e,t,s,n){const a=h.getRecoveryKeyId(e),i=JSON.stringify({alg:"A256GCM",ext:!0,k:s,key_ops:["encrypt","decrypt","wrapKey","unwrapKey"],kty:"oct"}),o={groupType:"user",groupId:e,keyType:"sym",keyName:"recovery",keyAlgo:{name:"AES-GCM",length:256},keyOps:["encrypt","decrypt","wrapKey","unwrapKey"]},c=JSON.parse(i),l=await q.subtle.importKey("jwk",c,{name:"AES-GCM",length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"]),u={keyId:a,key:l,keyInfo:o},p=h.getUserSecretKeyId(e);let d=n.filter(I=>I.wrappingKeyId==a&&I.keyId==p);if(d.length!=1)throw new Error("Recovery key not found");const f=d[0];let g=await h.keyEntryToWrappedKey(f);const w=await h.unwrapKey(g,u);return new ee(e,t,w,n)}static async instanceFromSecretKey(e,t,s,n){const a=h.getUserSecretKeyId(e),i=JSON.stringify({alg:"A256GCM",ext:!0,k:s,key_ops:["encrypt","decrypt","wrapKey","unwrapKey"],kty:"oct"}),o={groupType:"user",groupId:e,keyType:"sym",keyName:"default",keyAlgo:{name:"AES-GCM",length:256},keyOps:["encrypt","decrypt","wrapKey","unwrapKey"]},c=JSON.parse(i),l=await q.subtle.importKey("jwk",c,{name:"AES-GCM",length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"]),u={keyId:a,key:l,keyInfo:o};return new ee(e,t,u,n)}isEmpty(){return this.userSecret==null}async getRecoveryKey(){try{const e=this.getRecoveryKeyId(),t=await this.getRecoveryKeyById(e);return y("Found key!!",t),t}catch{console.error("Not using recovery key, returning actual key")}return await this.getSecretKeyById(this.getUserSecretId())}async getRecoveryKeyById(e){const t=await this.getKey(e),s=await h.serializeKey(t),n=JSON.parse(s.data);return{keyString:n.k,jwk:n,serializedRecoveryKey:s}}async getSecretKeyById(e){const t=await this.getKey(e),s=await h.serializeKey(t),n=JSON.parse(s.data);return{keyString:n.k,jwk:n,serializedUserSecret:s}}async getSecretKey(){return this.getSecretKeyById(this.getUserSecretId())}async serialize(){if(this.userSecret==null)return{userId:this.userId,accountId:this.accountId,userSecret:null,keyEntries:[]};const e=this.keyEntryList;return{userId:this.userId,accountId:this.accountId,userSecret:await h.serializeKey(this.userSecret,"self"),keyEntries:e}}getUserSecretId(){return this.userSecret.keyId}getUserSecret(){return this.getKey(this.getUserSecretId())}getUserPublicKeyId(){return h.getUserPublicKeyId(this.userId)}getRecoveryKeyId(){return h.getRecoveryKeyId(this.userId)}getRecoveryKeyInstance(){return this.getKey(this.getRecoveryKeyId())}getAcntSecretKeyId(){return h.getAcntSecretKeyId(this.accountId)}getAcntPublicKeyId(){return h.getAcntPublicKeyId(this.accountId)}getAcntPublicKey(){return this.getKey(this.getAcntPublicKeyId())}getAcntAdminSecretKeyId(){return h.getAcntAdminSecretKeyId(this.accountId)}async getAcntSecretKey(){return this.getKey(this.getAcntSecretKeyId())}async getAcntAdminSecretKey(){return this.getKey(this.getAcntAdminSecretKeyId())}async getInvKeyId(e){const t=await this.getKey(e);if(t==null)throw new Error("KM:Key not found: "+e);return h.invKeyInfoToId(t.keyInfo)}async getInvKey(e){const t=await this.getKey(e);if(t==null)throw new Error("KM:Key not found: "+e);if(t.keyInfo.keyType=="sym")return t;const s=await h.invKeyInfoToId(t.keyInfo),n=await this.getKey(s);if(n==null)throw new Error("KM:Key not found: "+s);return n}async _getKey(e,t=new Set){var n;if(e!=null&&e==((n=this.userSecret)==null?void 0:n.keyId))return this.userSecret;let s=this.keyInstanceMap.get(e);if(s==null){if(t.has(e))throw new Error("KM:Key circular reference detected: "+e);t.add(e),s=await this._unwrapKeyEntry(e,t)}return s}async getKey(e){return this._getKey(e,new Set)}async getKeyEntriesWithId(e){return this.keyEntryList.filter(t=>t.keyId==e)}async _unwrapKeyEntry(e,t){let s=await this.getKeyEntriesWithId(e);for(let n of s)try{return await this._unwrapKeyEntryInner(n,t)}catch{}throw new Error("KM:Key not found: "+e)}async _unwrapKeyEntryInner(e,t){if(e.isWrapped){if(e.unwrappingKeyId==null)throw new Error("KM:Wrapping key not found"+e.unwrappingKeyId);y("Unwrapping",e.keyId,e.unwrappingKeyId);const s=await h.keyEntryToWrappedKey(e),n=await this._getKey(e.unwrappingKeyId,t);if(n==null)throw new Error("KM:Wrapping key not found"+e.unwrappingKeyId);const a=await h.unwrapKey(s,n);return this.keyInstanceMap.set(e.keyId,a),a}else{const s=await h.keyEntryToKeyInstance(e);return this.keyInstanceMap.set(e.keyId,s),s}}async encryptSymmetric(e,t){let s=this.encoder.encode(t),n=q.getRandomValues(new Uint8Array(12)),a=await q.subtle.encrypt({name:e.keyInfo.keyAlgo.name,iv:n},e.key,s);return{encrypted:h.ab2str(a),iv:h.ab2str(n)}}async encryptSymmetricWithIV(e,t,s){let n=this.encoder.encode(t),a=await q.subtle.encrypt({name:e.keyInfo.keyAlgo.name,iv:s},e.key,n);return h.ab2str(a)}async decryptSymmetricWithCryptoKey(e,t,s,n){return await q.subtle.decrypt({name:t,iv:n},e,s)}async decryptSymmetric(e,t){let s=JSON.parse(t),n=await q.subtle.decrypt({name:e.keyInfo.keyAlgo.name,iv:h.str2ab(s.iv)},e.key,h.str2ab(s.encrypted));return this.decoder.decode(n)}async encryptString(e,t){const s=await this.getKey(e);if(!s)throw new Error("Key not found"+e);const n=await this.encryptSymmetric(s,t);return JSON.stringify(n)}async decryptString(e,t){const s=await this.getKey(e);if(!s)throw new Error("Key not found"+e);return await this.decryptSymmetric(s,t)}async wrap(e,t){const s=q.getRandomValues(new Uint8Array(12)),n=await q.subtle.exportKey("jwk",e.key),i=new TextEncoder().encode(JSON.stringify(n)),o=await q.subtle.encrypt({name:t.keyInfo.keyAlgo.name,iv:s},t.key,i);return{iv:s,wrappedData:o,keyAlgo:e.keyInfo.keyAlgo}}async unwrap(e,t){const s={name:t.keyInfo.keyAlgo.name,iv:e.iv},n=await q.subtle.decrypt(s,t.key,e.wrappedData),a=JSON.parse(h.ab2strPlain(n)),i=a;return{unwrappedKey:await q.subtle.importKey("jwk",i,e.keyAlgo,!0,a.key_ops),keyAlgo:e.keyAlgo}}async wrappedKeyToKeyInstance(e,t){const s={iv:h.str2ab(t.iv),wrappedData:h.str2ab(t.wrappedData),keyAlgo:h.deserializeAlgo(t.keyAlgo)},n=await this.unwrap(s,e);return{keyId:"temp",keyInfo:{groupType:"user",groupId:this.userId,keyType:"sym",keyName:"data",keyAlgo:n.keyAlgo,keyOps:["encrypt","decrypt"]},key:n.unwrappedKey}}async encryptObjectUsingKeyInstanceAndIV(e,t,s,n){for(const[a,i]of Object.entries(n))try{const o=i.type,c=s[a];if(c==null)continue;if(o=="string")typeof c=="string"?s[a]=JSON.stringify(await this.encryptSymmetricWithIV(e,c,t)):console.error("Failed to encrypt",a,c);else if(o=="object")if(typeof c=="object"){const l=await this.encryptSymmetricWithIV(e,JSON.stringify(c),t);s[a]={encryptedData:l}}else console.error("Failed to encrypt",a,c)}catch(o){throw console.error("Failed to encrypt",a,o),o}return s}async encryptOrReencryptObject(e,t,s,n=!1){return t.encInfo==null?await this.encryptObjectWithKeyIds(e,t,s,n):await this.encryptObjectUsingEncInfo(t.encInfo,t,s,n)}async encryptObjectUsingEncInfo(e,t,s,n=!1){y("DEC (re)? encrypting using encInfo",e,t);const{iv:a,keys:i}=e,o=h.str2ab(a),c=new Uint8Array(o);for(const l of i){const{unwrappingKeyId:u,wrappedEncKey:p,wrappingKeyId:d}=l;try{const f=await this.getKey(u);if(!f)continue;const g=n?f:await this.wrappedKeyToKeyInstance(f,p);return t=await this.encryptObjectUsingKeyInstanceAndIV(g,c,t,s),{obj:t,encInfo:e}}catch{continue}}throw new Error("Failed to encrypt object")}async encryptObjectWithKeyIds(e,t,s,n=!1){let a=[];const i=q.getRandomValues(new Uint8Array(12));if(n==!1){const o=await h.createSecretKey("onetime","onetime","onetime",["encrypt","decrypt"]);await this.encryptObjectUsingKeyInstanceAndIV(o,i,t,s);for(const c of e){let l=await this._generateWrappedKeyData(c,o);a.push(l)}}else{if(e.length!=1)throw new Error("Encryption only allowed for one key when woWrapKey is true");const o=e[0],c=await this.getKey(o);await this.encryptObjectUsingKeyInstanceAndIV(c,i,t,s),a.push({unwrappingKeyId:o,wrappingKeyId:o,wrappedEncKey:null})}return{obj:t,encInfo:{keys:a,v:1,iv:h.ab2str(i)}}}async _generateWrappedKeyData(e,t){const s=await this.getKey(e);if(!s)throw new Error("Key not found"+e);let n=e;s.keyInfo.keyType=="pub"&&(n=h.invKeyInfoToId(s.keyInfo));const a=await this.wrap(t,s);return{wrappedEncKey:{iv:h.ab2str(a.iv),wrappedData:h.ab2str(a.wrappedData),keyAlgo:h.serializeAlgo(a.keyAlgo)},wrappingKeyId:e,unwrappingKeyId:n}}async decryptObject(e,t,s){if(!(s!=null&&s.keys))return e;const{keys:n,iv:a}=s,i=h.str2ab(a);for(const o of n)try{let c=await this.decryptObjectWithEncInfoKey(e,t,o,i);if(c.decrypted)return c}catch{}return console.error("Failed to decrypt object with",s),e.decrypted=!1,e}async decryptObjectWithEncInfoKey(e,t,s,n){if(!s)return e;const{wrappedEncKey:a,wrappingKeyId:i,unwrappingKeyId:o}=s;let c=await this.getKey(o);if(!c)throw new Error("Key not found"+o);let l=null;if(a!=null){const u={iv:h.str2ab(a.iv),wrappedData:h.str2ab(a.wrappedData),keyAlgo:h.deserializeAlgo(a.keyAlgo)};l=await this.unwrap(u,c)}else l={unwrappedKey:c.key,keyAlgo:c.keyInfo.keyAlgo};for(const[u,p]of Object.entries(t)){const d=e[u],f=p.type;try{if(d==null||!p.encrypted)continue;if(f=="string"){const g=await this.decryptSymmetricWithCryptoKey(l.unwrappedKey,l.keyAlgo.name,h.str2ab(JSON.parse(d)),n);e[u]=h.ab2strUTF(g)}else if(f=="object"){if(typeof e[u]=="object")if(d.encryptedData){const g=await this.decryptSymmetricWithCryptoKey(l.unwrappedKey,l.keyAlgo.name,h.str2ab(d.encryptedData),n);e[u]=JSON.parse(h.ab2strUTF(g))}else e[u]=null}else console.error("Unsupported attr type,cannot decrypt",f)}catch{}}return e.decrypted=!0,e}}class ct{constructor(){A(this,"isLocked",!1);A(this,"queue",[])}async acquire(){return new Promise(e=>{this.isLocked?this.queue.push(e):(this.isLocked=!0,e())})}release(){if(this.queue.length>0){const e=this.queue.shift();e&&e()}else this.isLocked=!1}}const _t=new ct,ue=class ue{constructor(){A(this,"kms",{})}static getInstance(){return ue.instance||(ue.instance=new ue),ue.instance}async getKeyManager(e,t,s,n=!1){y("DEBUG: KM Getting** key manager for user",t,n),await _t.acquire();try{if(!n){if(this.kms[t])return y("DEBUG: KM Key Manager Found, skipping"),this.kms[t];const c=await z(`km_${t}`);if(c&&c.keys&&c.keys.length>0){y("DEBUG: KM Loading from local storage",c);try{return this.kms[t]=await ee.instanceFromSerialized(c),this.kms[t]}catch{}}}y("DEBUG: KM Getting keys from server for user",t,n);const a=await k.remoteRequest("/user/encryption/listKeys",{userId:t});let i=await this.getKeyManagerFromKeys(e,t,s,a);i?this.kms[t]=i:(y("DEBUG: KM Key Manager Not Found"),this.kms[t]=await ee.emptyInstance(t,s));const o=this.kms[t].serialize();await W(`km_${t}`,o)}finally{_t.release()}return this.kms[t]}async getKeyManagerFromKeys(e,t,s,n){try{if(y("getKeyManagerFromKeys for user",t),n&&n.length>0){let a=null;const i=await Y.getEncSecretyKey(t);if(i)try{y("Loading from secret key"),a=await ee.instanceFromSecretKey(t,s,i,n)}catch{}if(!a)try{const c=await Y.getEncPassword(t);c&&(y("Loading from password",c),a=await ee.instanceFromPassword(t,s,c,E.passwordEncSalt,n),y("Loaded from password"))}catch{}if(!a)try{const c=await Y.getEncRecoveryKey(t);y("Loading recovery key",c,t),c&&(y("Loading from recovery key"),a=await ee.instanceFromRecoveryKey(t,s,c,n),y("Loaded from recovery key"))}catch{}if(!a)if(e!=t){y("DEBUG: Loading from current user access");const l=await ue.getInstance().getKeyManager(e,e,s,!0),u=h.getUserSecretKeyId(t),p=await l.getSecretKeyById(u);if(p)try{a=await ee.instanceFromSecretKey(t,s,p==null?void 0:p.keyString,n)}catch{}else throw new Error("No secret key found")}else throw new Error("Unable to access users key manager: "+t);if(!a)throw new Error("Unable to access users key manager: "+t);const o=a.serialize();return await W(`km_${t}`,o),this.kms[t]=a,a}}catch(a){console.error(a)}return null}};A(ue,"instance");let fe=ue;const Js="/comment/list",Ys="/comment/create",$s="/item/infoById",Xs="/item/save",Qs="/item/update",Zs="/item/parents/bychildid",en="/library/root",tn="/library/uncategorized",sn="/library/archived",nn="/items/listWithFeedback",an="/collection/listByAccount",rn="/collection/listByUser",on="/collection/infoByUser",cn="/collection/listItemsWithInfoByUser",ln="/collection/getItemRelInfo",un="/item/pathtree",dn="/collection/create",pn="/collection/itemDetails/save",yn="/item/listWithInfoByUser",hn="/item/byIds",gn="/item/listSharedWithUser",fn="/item/listSharedByUser",as="/post/create",mn="/subscription/add",wn="/subscription/edit",In="/subscription/listForUser",kn="/subscription/listForRef",Sn="/changeLog/sync",Kn="/user/logVisit",Tn="/user/activity/list",xn="/user/activity/push",En="/user/activity/loglist",bn="/feed/getByPostId",Lt={encryptHistory:!0,encryptItems:!0,encryptPostsAndComments:!0},X={name:{type:"string",encrypted:!0},description:{type:"string",encrypted:!0},comment:{type:"string",encrypted:!0},url:{type:"string",encrypted:!0},meta:{type:"object",encrypted:!0},info:{type:"object",encrypted:!0},tags:{type:"object",encrypted:!0},patterns:{type:"object",encrypted:!0},key:{type:"string",encrypted:!0}},rs={version:2,route:{[Kn]:{encSettingsKey:"encryptHistory",withoutWrapKey:!0,encSchema:{type:"object",encryptedChildren:!0,properties:{context:{type:"object",encrypted:!0},info:{type:"object",encrypted:!0},url:{type:"string",encrypted:!0}}}},[Tn]:{decSchema:{type:"object",encTarget:"userActivity",properties:{userActivity:{type:"array",encryptedChildren:!0,properties:{context:{type:"object",encrypted:!0},url:{type:"string",encrypted:!0},info:{type:"object",encrypted:!0}}},count:{type:"number"}}}},[En]:{decSchema:{type:"object",encTarget:"userActivityLog",properties:{userActivityLog:{encryptedChildren:!0,type:"array",properties:{data:{type:"object",encrypted:!0}}}}}},[xn]:{encSettingsKey:"encryptHistory",defaultKeyType:"user",encSchema:{type:"object",properties:{data:{type:"object",encrypted:!0}}}},[as]:{encSettingsKey:"encryptPostsAndComments",defaultKeyType:"account",encSchema:{type:"object",properties:{data:{type:"object",encrypted:!0}}}},[mn]:{encSettingsKey:"encryptItems",defaultKeyType:"account",encSchema:{type:"object",properties:{data:{type:"object",encrypted:!0}}}},[In]:{encSettingsKey:"encryptItems",decSchema:{type:"array",encryptedChildren:!0,properties:{data:{type:"object",encrypted:!0}}}},[kn]:{encSettingsKey:"encryptItems",decSchema:{type:"array",encryptedChildren:!0,properties:{data:{type:"object",encrypted:!0}}}},[wn]:{encSettingsKey:"encryptItems",defaultKeyType:"account",encSchema:{type:"object",properties:{data:{type:"object",encrypted:!0}}}},[Ys]:{encSettingsKey:"encryptPostsAndComments",defaultKeyType:"account",encSchema:{type:"object",properties:{data:{type:"object",encrypted:!0}}}},[Js]:{decSchema:{type:"object",properties:{records:{encryptedChildren:!0,type:"array",properties:{data:{type:"object",encrypted:!0}}}}}},[bn]:{encSettingsKey:"encryptHistory",defaultKeyType:"account",decSchema:{type:"object",properties:{data:{encryptedChildren:!0,type:"object",properties:{data:{type:"object",encrypted:!0}}}}}},[cn]:{encSettingsKey:"encryptItems",decSchema:{type:"array",properties:{details:{type:"object",encryptedChildren:!0,properties:X},collectionRelation:{type:"object",encryptedChildren:!0,properties:{details:{type:"object",encrypted:!0}}}}}},[Zs]:{encSettingsKey:"encryptItems",decSchema:{type:"array",encryptedChildren:!0,properties:X}},[rn]:{encSettingsKey:"encryptItems",decSchema:{type:"array",properties:{details:{type:"object",encryptedChildren:!0,properties:X}}}},[gn]:{encSettingsKey:"encryptItems",decSchema:{type:"array",properties:{details:{type:"object",encryptedChildren:!0,properties:X}}}},[fn]:{encSettingsKey:"encryptItems",decSchema:{type:"array",properties:{details:{type:"object",encryptedChildren:!0,properties:X}}}},[sn]:{encSettingsKey:"encryptItems",decSchema:{type:"array",properties:{details:{type:"object",encryptedChildren:!0,properties:X}}}},[nn]:{encSettingsKey:"encryptItems",decSchema:{type:"array",properties:{details:{type:"object",encryptedChildren:!0,properties:X}}}},[tn]:{encSettingsKey:"encryptItems",decSchema:{type:"array",properties:{details:{type:"object",encryptedChildren:!0,properties:X}}}},[hn]:{encSettingsKey:"encryptItems",decSchema:{type:"array",encryptedChildren:!0,properties:X}},[un]:{encSettingsKey:"encryptItems",decSchema:{type:"array",properties:{item:{type:"object",encryptedChildren:!0,properties:X}}}},[en]:{encSettingsKey:"encryptItems",decSchema:{type:"array",properties:{details:{type:"object",encryptedChildren:!0,properties:X}}}},[yn]:{encSettingsKey:"encryptItems",decSchema:{type:"array",properties:{details:{type:"object",encryptedChildren:!0,properties:X}}}},[an]:{encSettingsKey:"encryptItems",decSchema:{encryptedChildren:!0,type:"array",properties:X}},[Sn]:{encSettingsKey:"encryptItems",decSchema:{type:"object",properties:{updatedItems:{type:"array",properties:{details:{type:"object",encryptedChildren:!0,properties:X}}}}}},[$s]:{encSettingsKey:"encryptItems",decSchema:{type:"object",properties:{details:{type:"object",encryptedChildren:!0,properties:X}}}},[on]:{encSettingsKey:"encryptItems",decSchema:{type:"object",encryptedChildren:!0,properties:X}},[ln]:{encSettingsKey:"encryptItems",defaultKeyType:"account",decSchema:{type:"object",encryptedChildren:!0,properties:{details:{type:"object",encrypted:!0}}}},[pn]:{encSettingsKey:"encryptItems",defaultKeyType:"account",encSchema:{type:"object",encTarget:"details",encryptedChildren:!0,properties:{details:{type:"object",encrypted:!0}}}},[Qs]:{encSettingsKey:"encryptItems",defaultKeyType:"account",encSchema:{type:"object",constraintFunc:async(r,e)=>{var t;return((t=r==null?void 0:r.data)==null?void 0:t.encInfo)!=null},encTarget:"data",properties:{data:{type:"object",encryptedChildren:!0,properties:X}}}},[dn]:{encSettingsKey:"encryptItems",defaultKeyType:"account",encSchema:{type:"object",encTarget:"data",properties:{data:{type:"object",encryptedChildren:!0,properties:X}}}},[Xs]:{encSettingsKey:"encryptItems",defaultKeyType:"account",encSchema:{type:"object",encTarget:"details",properties:{details:{type:"object",encryptedChildren:!0,properties:X}}}}}};class T{static async encStatus(e,t=!1){y("DEBUG: Getting enc status for ",e.user.username,t);const s=e.userId,n=e.accountId;if(!s||!n)throw console.error("User or account not defined",s,n),new M(`User or account not defined ${s} ${n}`);if(!t){const O=await Y.get(s,"encStatus");if(O){const j=O.cacheTime;if(j&&new Date().getTime()-j<1e3*60*60)return O.statusResults}}const a=await k.remoteRequest("/user/encryption/listKeys",{userId:s}),i=h.getUserSecretKeyId(s),o=h.getAcntSecretKeyId(n),c=h.getRecoveryKeyId(s),l=a.findIndex(O=>O.keyId===i)!=-1,u=a.findIndex(O=>O.keyId===c)!=-1,p=a.findIndex(O=>O.keyId===o)!=-1,d=a.filter(O=>O.selectType==="account").length>0,f=e.user.hasPassword==!0,g=await Y.getEncPassword(s),w=!!g;let I=!1,K=!1,R=!1;try{const j=await fe.getInstance().getKeyManagerFromKeys(e.currentUserId,s,n,a);if(j){try{if(I=await j.getUserSecret()!=null,e.user.type=="restricted"){const _=h.getUserSecretKeyId(s),F=await j.getSecretKeyById(_);await Y.setEncSecretyKey(s,F==null?void 0:F.keyString)}if(e.currentUserId==s&&f&&g)try{if(!await ee.instanceFromPassword(s,n,g,E.passwordEncSalt,a))throw new Error("Passwords not in sync");R=!0}catch(_){console.error(_.message,_);const F=await j.getUserSecret();y("Syncing encryption password"),await T.setEncPasswordWithKey(e.userId,g,F)}}catch{}try{K=await j.getAcntSecretKey()!=null}catch{}}}catch{}const N={hasPassword:f,hasCachedPassword:w,userEncSetup:l,userRecoveryKeyExists:u,acntEncSetup:p,userEncEnabled:I,acntEncEnabled:K,acntEncSupported:d,needsPassword:f&&l&&!w&&!I,passwordSyncVerified:R};return Y.set(s,"encStatus",{statusResults:N,cacheTime:new Date().getTime()}),N}static async setEncPassword(e,t){y("Changing enc password for ",e.user.username);const n=await(await T.getKeyManager(e)).getUserSecret();await T.setEncPasswordWithKey(e.userId,t,n)}static async setEncPasswordWithKey(e,t,s){const n=await h.generateNewPasswordWrappedKey(t,E.passwordEncSalt,s),a=await h.serializeWrappedKey(n.secretWrapped,"self"),i=await h.serializedKeyThingToKeyEntry(a);await k.remoteRequest("/user/encryption/saveUserKeys",{userId:e,keyList:[i]})}static async generateNewRecoveryKey(e){const s=await(await T.getKeyManager(e,!0)).getUserSecret(),n=await h.generateRecoveryKeys(e.userId,s),a=await h.serializeWrappedKey(n.recoveryKeyWrapped,"user"),i=await h.serializeWrappedKey(n.recoverySecretWrapped,"user"),o=await h.serializedKeyThingToKeyEntry(a),c=await h.serializedKeyThingToKeyEntry(i);await k.remoteRequest("/user/encryption/saveUserKeys",{userId:e.userId,keyList:[o,c]})}static async getRecoveryKey(e){const t=await T.getKeyManager(e,!0);try{return await t.getRecoveryKey()}catch(s){throw console.error("Error getting recovery key",s),new M("Error getting recovery key")}}static async saveRecoveryKeyOnServer(e){const s=await(await T.getKeyManager(e,!0)).getRecoveryKey();await k.remoteRequest("/auth/saveRecoveryKeyOnServer",{userId:e.userId,recoveryKey:s.keyString})}static async removeRecoveryKeyFromServer(e){await k.remoteRequest("/auth/removeRecoveryKeyFromServer",{userId:e.userId})}static async createAccountBackupKey(e){y("createAccountBackupKey enc password for ",e.user.username);const s=await(await T.getKeyManager(e)).getAcntSecretKey(),n=h.randomUUID(),a=await h.hashPassword(n,E.passwordEncSalt),i=await h.generateNewPasswordWrappedKey(a,E.passwordEncSalt,s),o=await h.serializeWrappedKey(i.secretWrapped,"admin"),c=await h.serializedKeyThingToKeyEntry(o);return await k.remoteRequest("/user/encryption/saveAccountKeys",{keyList:[c]}),n}static async shareAccountKey(e,t){y("DEBUG: shareAccountKey ",e.user.username);const s=await T.getKeyManager(e),a=(await k.remoteRequest("/user/encryption/listKeys",{userId:t})).find(p=>p.selectType==="user"&&p.keyType==="pub");y("Pub key entry",a);const i=await h.keyEntryToKeyInstance(a),o=await s.getAcntSecretKey(),c=await h.wrapKey(o,i),l=await h.serializeWrappedKey(c,"self"),u=await h.serializedKeyThingToKeyEntry(l);return await k.remoteRequest("/user/encryption/saveUserKeys",{userId:t,keyList:[u]}),!0}static async generateKeys(e){y("DEBUG: Generating keys");const t=e.userId,s=e.accountId;if(!t||!s)throw console.error("User or account not defined",t,s),new M(`User or account not defined ${t} ${s}`);await k.remoteRequest("/user/encryption/updateSettings",{userId:e.userId,encSettings:Lt});const n=await Y.getEncPassword(t),a=await k.remoteRequest("/user/encryption/listKeys",{userId:t}),i=a.filter(f=>f.selectType==="account"),o=a.filter(f=>f.selectType==="user"&&f.selectId==t),c=i.length==0,l=o.length==0,u=e.user.type=="admin";if(y("About to save keys"),u&&c&&l){if(y("Saving keys1"),!e.isCurrentUser)throw new M("Only current user can create new account");const f=await h.generateUserKeyBundleForNewAccount(t,s,n,E.passwordEncSalt),g=await h.serializedKeyMapToKeyEntries(f.user),w=await h.serializedKeyMapToKeyEntries(f.acnt);await k.remoteRequest("/user/encryption/saveUserKeys",{keyList:g,userId:t}),await k.remoteRequest("/user/encryption/saveAccountKeys",{keyList:w})}else if(u&&!c&&l){if(y("Saving keys2"),!e.isCurrentUser)throw new M("Only current user can create new account");const f=await h.generateUserKeyBundle(t,n,E.passwordEncSalt),g=await h.serializedKeyMapToKeyEntries(f);await k.remoteRequest("/user/encryption/saveUserKeys",{keyList:g,userId:t})}else if(!u&&l){y("Saving keys3");const f=await h.generateUserKeyBundle(t,n,E.passwordEncSalt),g=await h.serializedKeyMapToKeyEntries(f);await k.remoteRequest("/user/encryption/saveUserKeys",{userId:t,keyList:g});const w=await T.getKeyManager(e,!0),I=await w.getUserSecret(),K=await w.getAcntPublicKey(),R=await h.wrapKey(I,K),N={wrappedUserSecret:await h.serializeWrappedKey(R,"admin")},O=await h.serializedKeyMapToKeyEntries(N);await k.remoteRequest("/user/encryption/saveAccountKeys",{userId:t,keyList:O})}else throw console.error("User or account keys already exist"),new M("User or account keys already exist");if(await fe.getInstance().getKeyManager(e.currentUserId,t,s,!0))try{await T.shareAccountKey(new nt(e.currentUser),t)}catch(f){console.error("Error sharing account key",f)}return!0}static async generateKeysForRestrictedUser(e){const t=e.userId,s=e.accountId;await k.remoteRequest("/user/encryption/updateSettings",{userId:t,encSettings:Lt});const a=await(await fe.getInstance()).getKeyManager(e.currentUserId,e.currentUserId,s,!0),i=await a.getSecretKeyById(a.getUserSecretId());await Y.setEncSecretyKey(t,i==null?void 0:i.keyString);const o=await h.generateUserKeyBundleWithAccountSecretKey(e.userId,await a.getAcntSecretKey()),c=await h.serializedKeyMapToKeyEntries(o.user);await k.remoteRequest("/user/encryption/saveUserKeys",{userId:t,keyList:c});const l=await h.serializedKeyMapToKeyEntries(o.acnt);await k.remoteRequest("/user/encryption/saveAccountKeys",{keyList:l}),await T.shareAccountKey(new nt(e.currentUser),t)}static async getKeyManager(e,t=!1){y("DEBUG: Getting key manager",e.userId,e.accountId,t);const s=e.userId,n=e.accountId;if(!s||!n)return console.error("User or account not defined"),null;try{return await fe.getInstance().getKeyManager(e.currentUserId,s,n,t)}catch(a){return console.error("Error getting key manager",s,n,a),null}}static async getEncryptionKeys(e){y("Getting encryption keys");const t=await T.getKeyManager(e);return t?(y("KM",t),await t.serialize()):(console.error("KM not defined"),null)}static async listKeys(e,t=null){return await k.remoteRequest("/user/encryption/listKeys",{userId:t||e.userId})}static async listKeysWithStatus(e,t=null){t=t||e.userId;const s=await k.remoteRequest("/user/encryption/listKeys",{userId:t});y("Keys",s);const a=await fe.getInstance().getKeyManagerFromKeys(e.currentUserId,t,e.accountId,s);for(const i of s){let o=!1;try{await a.getKey(i.keyId)&&(o=!0)}catch(c){console.error("Error getting key",i,c)}i.keyAccess=o}return s}static async getKeyBackup(e){y("Getting key backup - encryption keys");const t=await T.getKeyManager(e);if(t)return await t.serialize();throw console.error("KM not defined"),new M("KM not defined")}static async encryptData(e,t){y("Encrypting data");const s=await T.getKeyManager(e);return s?await s.encryptString(s.getUserSecretId(),JSON.stringify(t)):(console.error("Encryption not setup for user"),null)}static async decryptData(e,t){y("Decrypting data");const s=await T.getKeyManager(e);return s?JSON.parse(await s.decryptString(s.getUserSecretId(),t)):(console.error("Encryption not setup for user"),null)}}class at{static async addSignoutCallback(e){this.signoutCallbacks.push(e)}static async runSignoutCallbacks(){for(const e of this.signoutCallbacks)await e()}}A(at,"signoutCallbacks",[]);let Qe=!1,ne;try{E.appType=="android"&&chrome&&chrome.runtime.connectNative&&(ne=chrome.runtime.connectNative(E.nativePortId),ne.onDisconnect.addListener(()=>{y("Native port disconnected"),Qe=!1,ne=void 0}))}catch(r){y("Native not available",r)}class ae{static async isConnected(){return Qe}static getNativePort(){return ne}static async nativePortConnect(){try{E.appType=="android"&&chrome&&chrome.runtime.connectNative&&(ne=chrome.runtime.connectNative(E.nativePortId),ne.onDisconnect.addListener(()=>{y("Native port disconnected"),Qe=!1,ne=void 0}))}catch(e){y("Native not available",e)}}static async sendNativeCurrentAuth(){const e=await H.getAuthInfo();ae.sendNativeMessage("authUpdate",e,t=>{Qe=!0})}static async sendNativeMessage(e,t,s=()=>{}){try{chrome.runtime.sendNativeMessage(E.nativePortId,{type:e,data:t},s)}catch(n){E.appType=="android"&&y("Native not enabled",n)}}static async updateDeviceToken(e){await k.remoteRequest("/user/client/updateDeviceToken",{deviceToken:e})}static async receivedNativeMessageViaPort(e,t){var s;if((t==null?void 0:t.type)=="DEVICE_INFO_UPDATE"){const n=(s=t==null?void 0:t.data)==null?void 0:s.deviceToken;W("deviceRegistrationToken",n),ae.updateDeviceToken(n)}else chrome.runtime.sendMessage(t,function(n){});e.postMessage({type:"ack",ackData:`Received Payload = ${JSON.stringify(t)}`})}static async sendNativeMessageViaPort(e){if(ne&&E.appType=="android")ne.postMessage(e);else throw console.error("Native port not available"),new Error("Native port not available")}}try{ne&&ne.onMessage.addListener(r=>{ae.receivedNativeMessageViaPort(ne,r)})}catch{}E.appType=="android"&&ae.sendNativeCurrentAuth();const Rn="/user/current";class m{static async getCurrentUserId(){var e;return String((e=(await H.getAuthInfo()).user)==null?void 0:e._id)}static async getAccountId(){var e;return(e=(await H.getAuthInfo()).user)==null?void 0:e.accountId}static async getCurrentAuthToken(){var e;return(e=(await H.getAuthInfo()).tokenData)==null?void 0:e.token}static async getUserById(e){return await k.remoteRequest("/user/info",{userId:e})}static async listAccountUsers(){return console.log("users: listAccountUsers"),await k.remoteRequest("/account/users")}static async createUser(e){const t=await k.remoteRequest("/auth/createUser",e);try{(await T.encStatus(await m.getUserRequestContext(),!0)).userEncEnabled&&await T.generateKeysForRestrictedUser(await m.getUserRequestContext(t._id))}catch(s){console.error("Error creating user",s)}return t}static async getUserRequestContext(e=null){const t=await m.getCurrentUser();return e!=null?new nt(t,await m.getUserById(e)):new nt(t)}static async getUserClientSettings(e){return e=e||await m.getCurrentUserId(),await z(`clientSettings_${e}`)}static async saveUserClientSettings({settings:e,userId:t}){t=t||await m.getCurrentUserId(),await W(`clientSettings_${t}`,e)}static async getCurrentUser(e=!1){let t=null;try{if(t=await H.getCurrentUser(),e||!t){if(!await H.isActive())return y("No active connection found"),null;y("Getting current user from server, refresh=",e);const s=await k.remoteRequest(Rn);if(s!=null&&s._id&&(t==null?void 0:t._id)==s._id)await H.updateUserObj(s),t=s;else throw y("User mismatch",s,t),new Error("User mismatch")}}catch(s){const n=s;if(console.error("Failed to get current user. Checking system status",n),n.status==401)throw console.error("User auth issue.  Maybe timeout.  Resetting connection"),await H.reset(),n}return t}static async getUserOptions(e=null,t=!1){const s=e;if(s){const n=await k.remoteRequest("/user/info",{userId:s});return n==null?void 0:n.options}else{t=t==!0;const n=await m.getCurrentUser(t);return n==null?void 0:n.options}}static async _updateAuth(e){if(y("update Auth Info:",e),e.success==!0)return await H.updateAuthInfo(e),ae.sendNativeMessage("authUpdate",e),!0;throw ae.sendNativeMessage("authUpdate",e),console.error("Error signin failed",e),Error("Login failed")}static async signOut(){await at.runSignoutCallbacks(),await H.reset();try{await k.remoteRequestRaw("/auth/signout")}catch(e){console.error("Error signing out",e)}}static async switchUser(e,t){const s=await m.getCurrentUser(),n=await m.getUserById(e);if(s.type=="admin"&&n.type=="restricted")try{const p=h.getUserSecretKeyId(e),f=await(await T.getKeyManager(await m.getUserRequestContext())).getSecretKeyById(p);await Y.setEncSecretyKey(e,f==null?void 0:f.keyString)}catch(p){console.error("Error getting recovery key, maybe encryption is not enabled?",p)}await at.runSignoutCallbacks();const a=await ht(),i=await k.remoteRequest("/auth/switchUser",{userId:e,pinpass:t?await h.hashPassword(t,E.passwordSalt):null,clientInfo:a});if(!i.success)throw new M("Switch user failed",400);const o=i.passwordForClient;if(o){const p=await h.hashPassword(o,E.passwordEncSalt);await Y.setEncPassword(e,p)}const c=i.recoveryKeyForClient;c&&await Y.setEncRecoveryKey(e,c);const l=await m._updateAuth(i),u=await z("deviceRegistrationToken");return u&&ae.updateDeviceToken(u),l}static async updatePIN(e,t){return await k.remoteRequest("/auth/updatePIN",{userId:e,pin:await h.hashPassword(t,E.passwordSalt)})}static async register(e,t){try{const{username:s,password:n,loginType:a,loginPayload:i,recaptchaToken:o,refData:c}=e,l=await h.hashPassword(n,E.passwordSalt);let u={...e,password:l};a!="internal"&&t&&(u.serverCopyOfPassword=n);const d=await(await k.remoteRequestRaw("/auth/register",u)).json();await m.updateAuthInfoOnClient(d,a,n);try{const g=await m.getUserRequestContext();await T.generateKeys(g),t&&await T.saveRecoveryKeyOnServer(g)}catch(g){throw console.error("Error setting up encryption for user",g),new M("Error setting up encryption",500,g)}const f=c==null?void 0:c.sessionToken;return f&&await k.remoteRequest("/auth/providerLogin/confirmSession",{sessionToken:f}),d.user}catch(s){throw console.error("Register Error:",s),new M(s.message,500,s)}}static async permissionOverride(e){return await k.remoteRequest("/auth/permissionOverride",{userId:e.userId,pinpass:await h.hashPassword(e.pinpass,E.passwordSalt)})}static async tokenSignIn(e){if(await m.getCurrentAuthToken()==e)return y("Already logged in with this token"),!0;await m.signOut();const s=await ht(),n=await k.remoteRequest("/auth/tokenLogin",{token:e,clientInfoData:s}),a=await m._updateAuth(n),i=await m.getCurrentUserId();if((n==null?void 0:n.recoveryKeyForClient)!=null&&await Y.setEncRecoveryKey(i,n.recoveryKeyForClient),(n==null?void 0:n.passwordForClient)!=null&&n.passwordForClient.length>0){const c=await h.hashPassword(n.passwordForClient,E.passwordEncSalt);await Y.setEncPassword(i,c)}const o=await T.encStatus(await m.getUserRequestContext(),!0);return y("Enc Status:",o),a}static async signIn(e){const{username:t,password:s,loginType:n,loginPayload:a={},recaptchaToken:i}=e;if(![Ct.apple,Ct.google].includes(n)&&s.length<8&&E.nodeEnv!="development")throw new M("Password must be at least 8 characters",400);try{const o=await ht(),c=await k.remoteRequestRaw("/auth/signin",{username:t,password:s?await h.hashPassword(s,E.passwordSalt):null,loginType:n,loginPayload:a,recaptchaToken:i,clientInfoData:o});y("signin Response",c);const l=await c.json();return await m.updateAuthInfoOnClient(l,n,s)}catch(o){throw console.error("Signin Error:",o),new M(o.message,500,o)}}static async updateAuthInfoOnClient(e,t,s=null){if(!e.success)throw console.error("Signin unsuccessful:",e.message,e.statusCode),e.statusCode==409?new M(e.message,e.statusCode,{message:e.message}):new M("Login failed:"+e.message,e.statusCode,{message:e.message});let n=s;if(["apple","google"].includes(t)&&n==null&&(n=e.passwordForClient),!await m._updateAuth(e))throw new M("Error updating auth",500);const i=await m.getCurrentUserId();if(n!=null){const c=await h.hashPassword(n,E.passwordEncSalt);await Y.setEncPassword(i,c)}e.recoveryKeyForClient!=null&&await Y.setEncRecoveryKey(i,e.recoveryKeyForClient);const o=await T.encStatus(await m.getUserRequestContext(),!0);return y("Enc Status:",o),e.user}static async updatePassword(e){const{userId:t,password:s,currentPassword:n,forceSkipCheck:a}=e,i=await m.getCurrentUser();let c=!t||t==i._id?i:await m.getUserById(t);const l=await m.getUserRequestContext(c._id),u=await T.encStatus(l,!0);if(u.userEncSetup){if(!a&&c.hasPassword&&!await m.checkPassword(n,c._id))throw new M("Incorrect current password",400);if(u.userEncSetup==!0&&u.userEncEnabled){const g=await h.hashPassword(s,E.passwordEncSalt);await T.setEncPassword(l,g)}}let p=null;c.hasPasswordCopy&&(p=s);const d=await k.remoteRequestRaw("/auth/updatePassword",{userId:t,password:await h.hashPassword(s,E.passwordSalt),passwordCopy:p});if(!await m.checkPassword(s,c._id))throw new M("Error testing password",400);return d}static async resetPassword(e){const{verificationCode:t,password:s}=e,n=await h.hashPassword(s,E.passwordSalt);return await k.remoteRequestRaw("/auth/resetPassword",{password:n,verificationCode:t})}static async clearCachedEncValues(e){const t=await m.getCurrentUser();await Y.clearEncPassword(e||t._id),await Y.clearEncRecoveryKey(e||t._id),await Y.clearEncSecretyKey(e||t._id)}static async setStoredPassword(e,t=null){const s=await h.hashPassword(e,E.passwordSalt);return await k.remoteRequest("/auth/setStoredPassword",{password:s,userId:t,passwordCopy:e})}static async clearStoredPassword(e,t=null){const s=await h.hashPassword(e,E.passwordSalt);return await k.remoteRequest("/auth/clearStoredPassword",{password:s,userId:t})}static async checkPassword(e,t=null){const s=await h.hashPassword(e,E.passwordSalt),n=await k.remoteRequest("/auth/checkPassword",{password:s,userId:t});if(n){const a=t||await m.getCurrentUserId(),i=await h.hashPassword(e,E.passwordEncSalt);await Y.setEncPassword(a,i)}return n}}function Mt(r,e){for(const[t,s]of Object.entries(e))t in r&&(s.type=="object"?r[t]=null:r[t]="**decryption error");return r.decryptionError=!0,r}class S{static async shareAccountKeyWithUser(e){const t=await m.getUserRequestContext();if(!(await T.encStatus(t,!0)).acntEncEnabled)throw new M("Error sharing account keys. Current user does not have access to account key.",400);const n=await m.getUserRequestContext(e),a=await T.encStatus(n,!0);if(a.acntEncSetup!=!0&&a.userEncSetup)return await T.shareAccountKey(t,e);throw new M("Error sharing account keys",400)}static async shareAccountKey(){const e=await m.getCurrentUser(),t=await m.getUserRequestContext(),s=await T.encStatus(t,!0);let n=0;if(s.acntEncEnabled==!0){const i=(await k.remoteRequest("/account/users")).filter(o=>o._id!=e._id);for(const o of i)try{const c=await m.getUserRequestContext(o._id),l=await T.encStatus(c,!0);y("targetUserEncStatus",l),l.acntEncSetup!=!0&&l.userEncSetup&&await T.shareAccountKey(t,o._id)&&n++}catch(c){console.error("Error sharing account key",o._id,c)}}else throw new M("Error sharing account keys",400);return n}static async allUserEncStatuses(){const e=await k.remoteRequest("/account/users");for(const t of e){const s=await m.getUserRequestContext(t._id),n=await T.encStatus(s,!0);t.encStatus=n}return e}static async recoverUsingSecretKey(e){y("DEBUG: Recovering account using secret key",e);const{recoveryKey:t,password:s}=e;if(!await m.checkPassword(s))throw new M("Incorrect current password",400);const a=await m.getCurrentUser(),i=await k.remoteRequest("/user/encryption/listKeys");if(i.length==0)throw new M("No keys found",400);try{let o=h.getRecoveryKeyId(a._id),c=i.filter(d=>d.keyId==o),l=null;c.length>0?(y("Found recovery key in key list, loading as recovery key"),l=await ee.instanceFromRecoveryKey(a._id,a.accountId,t,i)):(y("Recovery key not found in key list, loading as secret key"),l=await ee.instanceFromSecretKey(a._id,a.accountId,t,i));const u=await l.getUserSecret(),p=await h.hashPassword(s,E.passwordEncSalt);await T.setEncPasswordWithKey(a._id,p,u)}catch(o){throw console.error("Error recovering account",o),new M("Invalid recovery keys",o)}}static async decryptData(e,t,s){const n=await m.getUserRequestContext(),a=await T.getKeyManager(n);return await S.decryptDataWithKeyManager(a,e,t,s)}static async decryptDataWithKeyManager(e,t,s,n){if(n){new Date().getTime();let a=null;try{if(n.type=="array"){const i=[],o=n.properties,c=s;if(n.encryptedChildren==!0)for(const l of c)if(l.encrypted==!0){const u=await e.decryptObject(l,o,l.encInfo);i.push(u)}else i.push(l);else for(const l of c){const u=l;for(const[p,d]of Object.entries(o))if(d.encryptedChildren==!0){const f=d.properties,g=l[p];if((g==null?void 0:g.encrypted)==!0){const w=await e.decryptObject(g,f,g.encInfo);u[p]=w}}i.push(u)}a=i}else if(n.type=="object")if(n.encryptedChildren==!0)a=await e.decryptObject(s,n.properties,s.encInfo);else{a=s;const i=n.properties;for(const[o,c]of Object.entries(i))if(c.type=="object"){if(c.encryptedChildren==!0){const l=c.properties,u=s[o];if((u==null?void 0:u.encrypted)==!0){const p=await e.decryptObject(u,l,u.encInfo);a[o]=p}}}else if(c.type=="array"){const l=s[o],u=[],p=c.properties;if(c.encryptedChildren==!0)for(const d of l)if(d!=null&&d.encrypted)if(e)try{const f=await e.decryptObject(d,p,d.encInfo);u.push(f)}catch(f){console.error("Error decrypting:",f,d.encInfo),u.push(Mt(d,p))}else u.push(Mt(d,p));else u.push(d);else{const d=c.properties;for(const f of l){const g=f;for(const[w,I]of Object.entries(d))if(I.encryptedChildren==!0){const K=I.properties,R=f[w];if(R.encrypted==!0){const D=await e.decryptObject(R,K,R.encInfo);g[w]=D}}u.push(g)}a[o]=u}}}}catch(i){console.error("DEC Error decrypting data",t,i)}return a}else return s}static async encryptData(e,t,s,n,a,i=!1){if(y("DEC - encryptData",s,n),a.type=="object")if(a.encTarget==null||a.encTarget=="this"||a.encryptedChildren==!0){const{obj:o,encInfo:c}=await e.encryptOrReencryptObject(t,n,a.properties,i);return{...o,encInfo:c}}else{const o=n[a.encTarget],c=a.properties[a.encTarget].properties;if(y("DEC - ENC Target",o,c),!o)throw new Error("Invalid encTarget");const{obj:l,encInfo:u}=await e.encryptOrReencryptObject(t,o,c,i);return n[a.encTarget]={...l,encInfo:u},y("DEC - ENC Data",n),n}else throw new Error("Encryption not supported for this type")}static async remoteRequestEncryptionWrapper(e,t,s={},n={}){const a=rs.route[e]||{},{encSettingsKey:i,decSchema:o,encSchema:c,defaultKeyType:l,withoutWrapKey:u}=a,p=await m.getCurrentUser(),d=await m.getUserRequestContext(),f=await T.getKeyManager(d),g=(s==null?void 0:s.dontEncrypt)==!0,w=!!c&&!!f&&!g;let I=!!(p!=null&&p.encSettings)&&p.encSettings[i]==!0;const K=(s==null?void 0:s.forceEncrypt)==!0;if(w)if(K||I&&(!c.constraintFunc||c.constraintFunc!=null&&await c.constraintFunc(t,d))){const O=l=="account"?f.getAcntSecretKeyId():f.getUserSecretId();try{await f.getKey(O)&&(t=await S.encryptData(f,[O],e,t,c,u==!0))}catch(j){console.error("Error encrypting data",j)}}else y("DEC - Constraint failed",e,t);const R=await k.remoteRequest(e,t,s,n),D=!!o&&!!f;let N;return D?N=await S.decryptDataWithKeyManager(f,e,R,o):N=R,(s==null?void 0:s.includeSentDataInResult)==!0&&(N={result:N,sentData:t}),N}}class Ie{static async createPost(e,t={}){var g;const s=as;let{data:n,attachedItems:a,sharedWith:i}=e;const o=await m.getCurrentUser(),c=rs.route[s],{encSettingsKey:l,encSchema:u,defaultKeyType:p}=c;y("dataSettings settings",c,l);let d=!!(o!=null&&o.encSettings)&&o.encSettings[l]==!0;if((t==null?void 0:t.forceEncrypt)==!0&&(d=!0),d){const w=await m.getUserRequestContext(),I=await T.getKeyManager(w);let K=!!u&&!!I;if(K){const R=p=="account"?I.getAcntSecretKeyId():I.getUserSecretId();let D=[];if(i&&i.length>0){const O=(await m.listAccountUsers()).map(_=>_._id),j=i.filter(_=>!O.includes(_));if(j.length>0)try{D=j.map(F=>h.getUserPublicKeyId(F)).filter(F=>F!=null);for(const F of D){const se=await I.getKey(F)}}catch(_){y("error getting friend key ids",_),K=!1}j.length!=D.length&&(K=!1)}if(K){y("DEBUG: -enc enabled for post");let N=[R,...D];e=await S.encryptData(I,N,s,e,u);const O=e==null?void 0:e.encInfo,j=[];for(const _ of a)try{let F={..._};if(_.type=="imageFile"){const se=_.data,je=se.fileData,ze=se.imagePreview,He=await I.encryptObjectUsingEncInfo(O,{imagePreview:ze,fileData:je},{imagePreview:{encrypted:!0,type:"string"},fileData:{encrypted:!0,type:"string"}});F.data=He.obj}else if(_.type=="videoFile"){const se=await I.encryptObjectUsingEncInfo(O,{fileData:_.data.fileData,fileType:_.data.fileType,imageType:_.data.imageType,imagePreview:_.data.imagePreview},{imagePreview:{encrypted:!0,type:"string"},fileData:{encrypted:!0,type:"string"}});F.data=se.obj}else if(_.type=="libItem"){const se=await I.encryptObjectUsingEncInfo(O,{data:_.data},{data:{encrypted:!0,type:"object"}});F.data=(g=se==null?void 0:se.obj)==null?void 0:g.data}else{const se=await I.encryptObjectUsingEncInfo(O,{fileData:_.data.fileData,fileType:_.data.fileType},{fileData:{encrypted:!0,type:"string"}});F.data=se.obj}j.push(F)}catch(F){y("error encrypting attached items",F)}e.attachedItems=j}else e.attachedItems=a}else y("not encrypting -enc not working")}else y("not encrypting -enc disabled");return y("Outgoing postData",e),await k.remoteRequest(s,e,t,{})}static async createComment(e){var n;const{refType:t,refId:s}=e;if((e==null?void 0:e.encInfo)==null&&t=="post"){const i=(n=(await Ie.getPostById({id:s})).data)==null?void 0:n.encInfo;e.encInfo={...i}}return await S.remoteRequestEncryptionWrapper("/comment/create",e)}static async listComments(e){return await S.remoteRequestEncryptionWrapper("/comment/list",e)}static async listFeedItems(e){const t=await k.remoteRequest("/feed/list",e),s=Date.now(),{records:n}=t;if((n==null?void 0:n.length)>0){const a={type:"array",encryptedChildren:!0,properties:{data:{type:"object",encrypted:!0}}},i=n.map(g=>g.data),o=await S.decryptData("feedItemes decryption",i,a),c=[];for(const g of i)g.comments.length>0&&c.push(...g.comments);const l=await S.decryptData("feedItemes comments",c,a),u=Object.fromEntries(l.map(g=>[g._id,g]));for(const g of i)g.comments.length>0&&(g.comments=g.comments.map(w=>u[w._id]));const p=Object.fromEntries(o.map(g=>[g._id,g]));for(const g of n)g.data=p[g.data._id];const d=await m.getUserRequestContext(),f=await T.getKeyManager(d);for(const g of i)if(g.encInfo){const w=g.encInfo;if(g.attachedItems.length>0)for(const I of g.attachedItems)try{if(I.type=="imageFile"){const K=await f.decryptObject(I.data,{imagePreview:{encrypted:!0,type:"string"},image:{encrypted:!0,type:"string"},fileData:{encrypted:!0,type:"string"}},w);I.data=K}else if(I.type=="videoFile"){const K=await f.decryptObject(I.data,{imagePreview:{encrypted:!0,type:"string"},fileData:{encrypted:!0,type:"string"}},w);I.data=K}else if(I.type=="libItem"){const K=await f.decryptObject({data:I.data},{data:{encrypted:!0,type:"object"}},w);I.data=K==null?void 0:K.data}else{const K=await f.decryptObject({data:I.data},{fileData:{encrypted:!0,type:"string"},fileType:{encrypted:!1,type:"string"}},w);I.data=K==null?void 0:K.data}}catch(K){y("error decrypting attached items",K)}}}return y("Timer listFeedItems",Date.now()-s),{records:n}}static async getPostById(e){var a,i,o;const t=await S.remoteRequestEncryptionWrapper("/feed/getByPostId",e);if(t.deletedAt!=null)return t;if(((a=t==null?void 0:t.data)==null?void 0:a.comments.length)>0){const c={type:"array",encryptedChildren:!0,properties:{data:{type:"object",encrypted:!0}}},l=await S.decryptData("comment decryption",t.data.comments,c);t.data.comments=l}const s=(i=t==null?void 0:t.data)==null?void 0:i.attachedItems,n=(o=t.data)==null?void 0:o.encInfo;if(n&&s&&s.length>0){const c=await m.getUserRequestContext(),l=await T.getKeyManager(c);for(const u of s)if(u.type=="imageFile"){const p=await l.decryptObject(u.data,{imagePreview:{encrypted:!0,type:"string"},image:{encrypted:!0,type:"string"},fileData:{encrypted:!0,type:"string"}},n);u.data=p}else if(u.type=="videoFile"){const p=await l.decryptObject(u.data,{imagePreview:{encrypted:!0,type:"string"},fileData:{encrypted:!0,type:"string"}},n);u.data=p}else{const p=await l.decryptObject({data:u.data},{data:{encrypted:!0,type:"object"}},n);u.data=p.data}t.data.attachedItems=s}return t}}const Ue=[];Ue.push({path:"/client/feed/getByPostId",handler:async(r,e,t)=>await Ie.getPostById(e)});Ue.push({path:"/client/feed/list",handler:async(r,e,t)=>await Ie.listFeedItems(e)});Ue.push({path:"/client/post/create",handler:async(r,e,t)=>await Ie.createPost(e)});Ue.push({path:"/client/comment/create",handler:async(r,e,t)=>await Ie.createComment(e)});Ue.push({path:"/client/comment/list",handler:async(r,e,t)=>await Ie.listComments(e)});const Un={indexRebuilding:!1,indexRebuildingProgress:0,indexRebuildingTotal:0,startTime:0,endTime:0,progress:1};let Ve=null;const Je=Math.floor(Math.random()*1e9);class Fe{constructor(e){A(this,"idx_id");A(this,"statusKey");this.idx_id=e,this.statusKey="idxStatus_"+this.idx_id}static async getInstance(e){return new Fe(e)}async getStatus(){return await z(this.statusKey)||{...Un}}async startBuild(){y("SIndex: StatusTracker startBuild");const e=await this.getStatus();e.startProcId=Je,e.indexRebuilding=!0,e.indexRebuildingProgress=0,e.indexRebuildingTotal=0,e.startTime=Date.now(),e.endTime=0,e.lastSeen=Date.now(),e.progress=0,await W(this.statusKey,e),await this.removeKeepAliveInterval(),await this.createKeepAliveInterval()}async updateKeepAlive(){const e=await this.getStatus();e.lastSeen=Date.now(),await W(this.statusKey,e)}async createKeepAliveInterval(){Ve=setInterval(async()=>{await this.updateKeepAlive()},1e3*3)}async removeKeepAliveInterval(){Ve&&(clearInterval(Ve),Ve=null)}async addProgress(e){const t=await this.getStatus();t.progress+=e,await W(this.statusKey,t)}async setProgress(e){const t=await this.getStatus();t.progress=e,await W(this.statusKey,t)}async isSameProc(){return(await this.getStatus()).startProcId==Je}async endBuild(){const e=await this.getStatus(),t=await this.isBuilding(!0),s=e.startProcId==Je&&t;return e.indexRebuilding=!1,e.endTime=Date.now(),e.lastSeen=Date.now(),e.progress=1,await W(this.statusKey,e),await this.removeKeepAliveInterval(),y("SIndex: StatusTracker endBuild",e),s}async isBuilding(e=!1){const t=await this.getStatus(),s=t.lastSeen||0,n=t.startProcId==Je,a=Date.now()-s>1e3*8,i=Date.now()-t.startTime<1e3*60*5;return e||y(`SIndex: StatusTracker isbuilding status: ${t.indexRebuilding} lastSeenExpired: ${a} buildTimeExpired: ${i} sameProc: ${n}`),a?!1:t.indexRebuilding&&i}async statusInfo(){const e=await this.getStatus(),t=await this.isBuilding(!0);return{idxStatus:e,indexRebuilding:t}}}function gt(r){r=r.replace(/https?:\/\//,"");const e=r.split("/"),[t,s]=e[0].split(":"),n=e.slice(1).join("/");return{hostname:t,pathname:n,port:s}}function An(r){const e=r.split(".");let t="",s=[];s.push("*");for(let n=e.length-1;n>=0;n--)t==""?t=e[n]:t=e[n]+"."+t,s.push("*."+t),s.push(t);return s}function Cn(r){const e=r.split("");let t=[];t.push("*");for(let s=0;s<e.length-1;s++)t.push(r.substring(0,s)+"*"),/[\%\&\?\#\=]/.test(e[s])&&t.push(r.substring(0,s));return r.length>0&&(t.push(r),t.push(r+"*"),t.push(r+"/*")),t}function Dn(r){let e=[];return e.push(r),e.push("*."+r),r.startsWith("www.")&&e.push("*."+r.replace("www.","")),e}function vn(r){let e=[];return r.length>0?(e.push(r),e.push(r+"*"),e.push(r+"/*")):e.push("*"),e}class _n{constructor(e={}){A(this,"lookup");A(this,"_revLookup",{});this.lookup=e||{}}add(e,t){for(let s of t){const n=gt(s);let a=this.lookup[n.hostname]||{};a[n.pathname]=e,this.lookup[n.hostname]=a}}_buildRevLookup(){this._revLookup={};for(const[e,t]of Object.entries(this.lookup))for(const[s,n]of Object.entries(t)){let a=this._revLookup[n]||[];a.push({hostname:e,path:s}),this._revLookup[n]=a}}remove(e){try{this._revLookup||this._buildRevLookup();const t=this._revLookup[e]||[];for(const s of t)delete this.lookup[s.hostname][s.path]}catch(t){console.error("idx remove error",e,t)}}getExactMatches(e){e.startsWith("http")||(e="http://"+e);const t=gt(e),s=t.hostname,n=Dn(s),a=vn(t.pathname),i=new Set;for(let o of n)if(o in this.lookup){const c=this.lookup[o];for(let l of a)l in c&&i.add(c[l])}return Array.from(i)}getMatches(e,t=!1){e.startsWith("http")||(e="http://"+e);const s=gt(e),n=s.hostname,a=An(n),i=Cn(s.pathname),o=new Set;let c=null,l=null;for(let u of a)if(u in this.lookup){const p=this.lookup[u];for(let d of i)d in p&&(o.add(p[d]),t&&(l==null||c&&c.length<d.length)&&(l=p[d],c=d))}return t&&l?[l]:Array.from(o)}}var G;function Ze(r){return typeof r<"u"?r:!0}function Ot(r){const e=Array(r);for(let t=0;t<r;t++)e[t]=B();return e}function B(){return Object.create(null)}function Ln(r,e){return e.length-r.length}function te(r){return typeof r=="string"}function ye(r){return typeof r=="object"}function At(r){return typeof r=="function"}function is(r,e){var t=Mn;if(r&&(e&&(r=et(r,e)),this.H&&(r=et(r,this.H)),this.J&&1<r.length&&(r=et(r,this.J)),t||t==="")){if(e=r.split(t),this.filter){r=this.filter,t=e.length;const s=[];for(let n=0,a=0;n<t;n++){const i=e[n];i&&!r[i]&&(s[a++]=i)}r=s}else r=e;return r}return r}const Mn=/[\p{Z}\p{S}\p{P}\p{C}]+/u,On=/[\u0300-\u036f]/g;function Pt(r,e){const t=Object.keys(r),s=t.length,n=[];let a="",i=0;for(let o=0,c,l;o<s;o++)c=t[o],(l=r[c])?(n[i++]=$(e?"(?!\\b)"+c+"(\\b|_)":c),n[i++]=l):a+=(a?"|":"")+c;return a&&(n[i++]=$(e?"(?!\\b)("+a+")(\\b|_)":"("+a+")"),n[i]=""),n}function et(r,e){for(let t=0,s=e.length;t<s&&(r=r.replace(e[t],e[t+1]),r);t+=2);return r}function $(r){return new RegExp(r,"g")}function os(r){let e="",t="";for(let s=0,n=r.length,a;s<n;s++)(a=r[s])!==t&&(e+=t=a);return e}var Pn={encode:cs,F:!1,G:""};function cs(r){return is.call(this,(""+r).toLowerCase(),!1)}const ls={},ke={};function us(r){De(r,"add"),De(r,"append"),De(r,"search"),De(r,"update"),De(r,"remove")}function De(r,e){r[e+"Async"]=function(){const t=this,s=arguments;var n=s[s.length-1];let a;return At(n)&&(a=n,delete s[s.length-1]),n=new Promise(function(i){setTimeout(function(){t.async=!0;const o=t[e].apply(t,s);t.async=!1,i(o)})}),a?(n.then(a),this):n}}function ds(r,e,t,s){const n=r.length;let a=[],i,o,c=0;s&&(s=[]);for(let l=n-1;0<=l;l--){const u=r[l],p=u.length,d=B();let f=!i;for(let g=0;g<p;g++){const w=u[g],I=w.length;if(I)for(let K=0,R,D;K<I;K++)if(D=w[K],i){if(i[D]){if(!l){if(t)t--;else if(a[c++]=D,c===e)return a}(l||s)&&(d[D]=1),f=!0}if(s&&(R=(o[D]||0)+1,o[D]=R,R<n)){const N=s[R-2]||(s[R-2]=[]);N[N.length]=D}}else d[D]=1}if(s)i||(o=d);else if(!f)return[];i=d}if(s)for(let l=s.length-1,u,p;0<=l;l--){u=s[l],p=u.length;for(let d=0,f;d<p;d++)if(f=u[d],!i[f]){if(t)t--;else if(a[c++]=f,c===e)return a;i[f]=1}}return a}function Wn(r,e){const t=B(),s=B(),n=[];for(let a=0;a<r.length;a++)t[r[a]]=1;for(let a=0,i;a<e.length;a++){i=e[a];for(let o=0,c;o<i.length;o++)c=i[o],t[c]&&!s[c]&&(s[c]=1,n[n.length]=c)}return n}function lt(r){this.l=r!==!0&&r,this.cache=B(),this.h=[]}function ps(r,e,t){ye(r)&&(r=r.query);let s=this.cache.get(r);return s||(s=this.search(r,e,t),this.cache.set(r,s)),s}lt.prototype.set=function(r,e){if(!this.cache[r]){var t=this.h.length;for(t===this.l?delete this.cache[this.h[t-1]]:t++,--t;0<t;t--)this.h[t]=this.h[t-1];this.h[0]=r}this.cache[r]=e};lt.prototype.get=function(r){const e=this.cache[r];if(this.l&&e&&(r=this.h.indexOf(r))){const t=this.h[r-1];this.h[r-1]=this.h[r],this.h[r]=t}return e};const Nn={memory:{charset:"latin:extra",D:3,B:4,m:!1},performance:{D:3,B:3,s:!1,context:{depth:2,D:1}},match:{charset:"latin:extra",G:"reverse"},score:{charset:"latin:advanced",D:20,B:3,context:{depth:3,D:9}},default:{}};function ys(r,e,t,s,n,a,i,o){setTimeout(function(){const c=r(t?t+"."+s:s,JSON.stringify(i));c&&c.then?c.then(function(){e.export(r,e,t,n,a+1,o)}):e.export(r,e,t,n,a+1,o)})}function we(r,e){if(!(this instanceof we))return new we(r);var t;if(r){te(r)?r=Nn[r]:(t=r.preset)&&(r=Object.assign({},t[t],r)),t=r.charset;var s=r.lang;te(t)&&(t.indexOf(":")===-1&&(t+=":default"),t=ke[t]),te(s)&&(s=ls[s])}else r={};let n,a,i=r.context||{};if(this.encode=r.encode||t&&t.encode||cs,this.register=e||B(),this.D=n=r.resolution||9,this.G=e=t&&t.G||r.tokenize||"strict",this.depth=e==="strict"&&i.depth,this.l=Ze(i.bidirectional),this.s=a=Ze(r.optimize),this.m=Ze(r.fastupdate),this.B=r.minlength||1,this.C=r.boost,this.map=a?Ot(n):B(),this.A=n=i.resolution||1,this.h=a?Ot(n):B(),this.F=t&&t.F||r.rtl,this.H=(e=r.matcher||s&&s.H)&&Pt(e,!1),this.J=(e=r.stemmer||s&&s.J)&&Pt(e,!0),t=e=r.filter||s&&s.filter){t=e,s=B();for(let o=0,c=t.length;o<c;o++)s[t[o]]=1;t=s}this.filter=t,this.cache=(e=r.cache)&&new lt(e)}G=we.prototype;G.append=function(r,e){return this.add(r,e,!0)};G.add=function(r,e,t,s){if(e&&(r||r===0)){if(!s&&!t&&this.register[r])return this.update(r,e);if(e=this.encode(e),s=e.length){const l=B(),u=B(),p=this.depth,d=this.D;for(let f=0;f<s;f++){let g=e[this.F?s-1-f:f];var n=g.length;if(g&&n>=this.B&&(p||!u[g])){var a=Ye(d,s,f),i="";switch(this.G){case"full":if(2<n){for(a=0;a<n;a++)for(var o=n;o>a;o--)if(o-a>=this.B){var c=Ye(d,s,f,n,a);i=g.substring(a,o),ve(this,u,i,c,r,t)}break}case"reverse":if(1<n){for(o=n-1;0<o;o--)i=g[o]+i,i.length>=this.B&&ve(this,u,i,Ye(d,s,f,n,o),r,t);i=""}case"forward":if(1<n){for(o=0;o<n;o++)i+=g[o],i.length>=this.B&&ve(this,u,i,a,r,t);break}default:if(this.C&&(a=Math.min(a/this.C(e,g,f)|0,d-1)),ve(this,u,g,a,r,t),p&&1<s&&f<s-1){for(n=B(),i=this.A,a=g,o=Math.min(p+1,s-f),n[a]=1,c=1;c<o;c++)if((g=e[this.F?s-1-f-c:f+c])&&g.length>=this.B&&!n[g]){n[g]=1;const w=this.l&&g>a;ve(this,l,w?a:g,Ye(i+(s/2>i?0:1),s,f,o-1,c-1),r,t,w?g:a)}}}}}this.m||(this.register[r]=1)}}return this};function Ye(r,e,t,s,n){return t&&1<r?e+(s||0)<=r?t+(n||0):(r-1)/(e+(s||0))*(t+(n||0))+1|0:0}function ve(r,e,t,s,n,a,i){let o=i?r.h:r.map;(!e[t]||i&&!e[t][i])&&(r.s&&(o=o[s]),i?(e=e[t]||(e[t]=B()),e[i]=1,o=o[i]||(o[i]=B())):e[t]=1,o=o[t]||(o[t]=[]),r.s||(o=o[s]||(o[s]=[])),a&&o.includes(n)||(o[o.length]=n,r.m&&(r=r.register[n]||(r.register[n]=[]),r[r.length]=o)))}G.search=function(r,e,t){t||(!e&&ye(r)?(t=r,r=t.query):ye(e)&&(t=e));let s=[],n,a,i=0;if(t){r=t.query||r,e=t.limit,i=t.offset||0;var o=t.context;a=t.suggest}if(r&&(r=this.encode(""+r),n=r.length,1<n)){t=B();var c=[];for(let u=0,p=0,d;u<n;u++)if((d=r[u])&&d.length>=this.B&&!t[d])if(this.s||a||this.map[d])c[p++]=d,t[d]=1;else return s;r=c,n=r.length}if(!n)return s;e||(e=100),o=this.depth&&1<n&&o!==!1,t=0;let l;o?(l=r[0],t=1):1<n&&r.sort(Ln);for(let u,p;t<n;t++){if(p=r[t],o?(u=Wt(this,s,a,e,i,n===2,p,l),a&&u===!1&&s.length||(l=p)):u=Wt(this,s,a,e,i,n===1,p),u)return u;if(a&&t===n-1){if(c=s.length,!c){if(o){o=0,t=-1;continue}return s}if(c===1)return hs(s[0],e,i)}}return ds(s,e,i,a)};function Wt(r,e,t,s,n,a,i,o){let c=[],l=o?r.h:r.map;if(r.s||(l=Nt(l,i,o,r.l)),l){let u=0;const p=Math.min(l.length,o?r.A:r.D);for(let d=0,f=0,g,w;d<p&&!((g=l[d])&&(r.s&&(g=Nt(g,i,o,r.l)),n&&g&&a&&(w=g.length,w<=n?(n-=w,g=null):(g=g.slice(n),n=0)),g&&(c[u++]=g,a&&(f+=g.length,f>=s))));d++);if(u){if(a)return hs(c,s,0);e[e.length]=c;return}}return!t&&c}function hs(r,e,t){return r=r.length===1?r[0]:[].concat.apply([],r),t||r.length>e?r.slice(t,t+e):r}function Nt(r,e,t,s){return t?(s=s&&e>t,r=(r=r[s?e:t])&&r[s?t:e]):r=r[e],r}G.contain=function(r){return!!this.register[r]};G.update=function(r,e){return this.remove(r).add(r,e)};G.remove=function(r,e){const t=this.register[r];if(t){if(this.m)for(let s=0,n;s<t.length;s++)n=t[s],n.splice(n.indexOf(r),1);else rt(this.map,r,this.D,this.s),this.depth&&rt(this.h,r,this.A,this.s);if(e||delete this.register[r],this.cache){e=this.cache;for(let s=0,n,a;s<e.h.length;s++)a=e.h[s],n=e.cache[a],n.includes(r)&&(e.h.splice(s--,1),delete e.cache[a])}}return this};function rt(r,e,t,s,n){let a=0;if(r.constructor===Array)if(n)e=r.indexOf(e),e!==-1?1<r.length&&(r.splice(e,1),a++):a++;else{n=Math.min(r.length,t);for(let i=0,o;i<n;i++)(o=r[i])&&(a=rt(o,e,t,s,n),s||a||delete r[i])}else for(let i in r)(a=rt(r[i],e,t,s,n))||delete r[i];return a}G.searchCache=ps;G.export=function(r,e,t,s,n,a){let i=!0;typeof a>"u"&&(i=new Promise(l=>{a=l}));let o,c;switch(n||(n=0)){case 0:if(o="reg",this.m){c=B();for(let l in this.register)c[l]=1}else c=this.register;break;case 1:o="cfg",c={doc:0,opt:this.s?1:0};break;case 2:o="map",c=this.map;break;case 3:o="ctx",c=this.h;break;default:typeof t>"u"&&a&&a();return}return ys(r,e||this,t,o,s,n,c,a),i};G.import=function(r,e){if(e)switch(te(e)&&(e=JSON.parse(e)),r){case"cfg":this.s=!!e.opt;break;case"reg":this.m=!1,this.register=e;break;case"map":this.map=e;break;case"ctx":this.h=e}};us(we.prototype);function Fn(r){r=r.data;var e=self._index;const t=r.args;var s=r.task;switch(s){case"init":s=r.options||{},r=r.factory,e=s.encode,s.cache=!1,e&&e.indexOf("function")===0&&(s.encode=Function("return "+e)()),r?(Function("return "+r)()(self),self._index=new self.FlexSearch.Index(s),delete self.FlexSearch):self._index=new we(s);break;default:r=r.id,e=e[s].apply(e,t),postMessage(s==="search"?{id:r,msg:e}:{id:r})}}let Ft=0;function Re(r){if(!(this instanceof Re))return new Re(r);var e;r?At(e=r.encode)&&(r.encode=e.toString()):r={},(e=(self||window)._factory)&&(e=e.toString());const t=typeof window>"u"&&self.exports,s=this;this.o=qn(e,t,r.worker),this.h=B(),this.o&&(t?this.o.on("message",function(n){s.h[n.id](n.msg),delete s.h[n.id]}):this.o.onmessage=function(n){n=n.data,s.h[n.id](n.msg),delete s.h[n.id]},this.o.postMessage({task:"init",factory:e,options:r}))}qe("add");qe("append");qe("search");qe("update");qe("remove");function qe(r){Re.prototype[r]=Re.prototype[r+"Async"]=function(){const e=this,t=[].slice.call(arguments);var s=t[t.length-1];let n;return At(s)&&(n=s,t.splice(t.length-1,1)),s=new Promise(function(a){setTimeout(function(){e.h[++Ft]=a,e.o.postMessage({task:r,id:Ft,args:t})})}),n?(s.then(n),this):s}}function qn(r,e,t){let s;try{s=e?new(require("worker_threads")).Worker(__dirname+"/node/node.js"):r?new Worker(URL.createObjectURL(new Blob(["onmessage="+Fn.toString()],{type:"text/javascript"}))):new Worker(te(t)?t:"/src/3rdparty/module-min/worker/worker.js?worker",{type:"module"})}catch{}return s}function We(r){if(!(this instanceof We))return new We(r);var e=r.document||r.doc||r,t;this.K=[],this.h=[],this.A=[],this.register=B(),this.key=(t=e.key||e.id)&&$e(t,this.A)||"id",this.m=Ze(r.fastupdate),this.C=(t=e.store)&&t!==!0&&[],this.store=t&&B(),this.I=(t=e.tag)&&$e(t,this.A),this.l=t&&B(),this.cache=(t=r.cache)&&new lt(t),r.cache=!1,this.o=r.worker,this.async=!1,t=B();let s=e.index||e.field||e;te(s)&&(s=[s]);for(let n=0,a,i;n<s.length;n++)a=s[n],te(a)||(i=a,a=a.field),i=ye(i)?Object.assign({},r,i):r,this.o&&(t[a]=new Re(i),t[a].o||(this.o=!1)),this.o||(t[a]=new we(i,this.register)),this.K[n]=$e(a,this.A),this.h[n]=a;if(this.C)for(r=e.store,te(r)&&(r=[r]),e=0;e<r.length;e++)this.C[e]=$e(r[e],this.A);this.index=t}function $e(r,e){const t=r.split(":");let s=0;for(let n=0;n<t.length;n++)r=t[n],0<=r.indexOf("[]")&&(r=r.substring(0,r.length-2))&&(e[s]=!0),r&&(t[s++]=r);return s<t.length&&(t.length=s),1<s?t:t[0]}function St(r,e){if(te(e))r=r[e];else for(let t=0;r&&t<e.length;t++)r=r[e[t]];return r}function Kt(r,e,t,s,n){if(r=r[n],s===t.length-1)e[n]=r;else if(r)if(r.constructor===Array)for(e=e[n]=Array(r.length),n=0;n<r.length;n++)Kt(r,e,t,s,n);else e=e[n]||(e[n]=B()),n=t[++s],Kt(r,e,t,s,n)}function Tt(r,e,t,s,n,a,i,o){if(r=r[i])if(s===e.length-1){if(r.constructor===Array){if(t[s]){for(e=0;e<r.length;e++)n.add(a,r[e],!0,!0);return}r=r.join(" ")}n.add(a,r,o,!0)}else if(r.constructor===Array)for(i=0;i<r.length;i++)Tt(r,e,t,s,n,a,i,o);else i=e[++s],Tt(r,e,t,s,n,a,i,o)}G=We.prototype;G.add=function(r,e,t){if(ye(r)&&(e=r,r=St(e,this.key)),e&&(r||r===0)){if(!t&&this.register[r])return this.update(r,e);for(let s=0,n,a;s<this.h.length;s++)a=this.h[s],n=this.K[s],te(n)&&(n=[n]),Tt(e,n,this.A,0,this.index[a],r,n[0],t);if(this.I){let s=St(e,this.I),n=B();te(s)&&(s=[s]);for(let a=0,i,o;a<s.length;a++)if(i=s[a],!n[i]&&(n[i]=1,o=this.l[i]||(this.l[i]=[]),!t||!o.includes(r))&&(o[o.length]=r,this.m)){const c=this.register[r]||(this.register[r]=[]);c[c.length]=o}}if(this.store&&(!t||!this.store[r])){let s;if(this.C){s=B();for(let n=0,a;n<this.C.length;n++)a=this.C[n],te(a)?s[a]=e[a]:Kt(e,s,a,0,a[0])}this.store[r]=s||e}}return this};G.append=function(r,e){return this.add(r,e,!0)};G.update=function(r,e){return this.remove(r).add(r,e)};G.remove=function(r){if(ye(r)&&(r=St(r,this.key)),this.register[r]){for(var e=0;e<this.h.length&&(this.index[this.h[e]].remove(r,!this.o),!this.m);e++);if(this.I&&!this.m)for(let t in this.l){e=this.l[t];const s=e.indexOf(r);s!==-1&&(1<e.length?e.splice(s,1):delete this.l[t])}this.store&&delete this.store[r],delete this.register[r]}return this};G.search=function(r,e,t,s){t||(!e&&ye(r)?(t=r,r=""):ye(e)&&(t=e,e=0));let n=[],a=[],i,o,c,l,u,p,d=0;if(t)if(t.constructor===Array)c=t,t=null;else{if(r=t.query||r,c=(i=t.pluck)||t.index||t.field,l=t.tag,o=this.store&&t.enrich,u=t.bool==="and",e=t.limit||e||100,p=t.offset||0,l&&(te(l)&&(l=[l]),!r)){for(let g=0,w;g<l.length;g++)(w=Bn.call(this,l[g],e,p,o))&&(n[n.length]=w,d++);return d?n:[]}te(c)&&(c=[c])}c||(c=this.h),u=u&&(1<c.length||l&&1<l.length);const f=!s&&(this.o||this.async)&&[];for(let g=0,w,I,K;g<c.length;g++){let R;if(I=c[g],te(I)||(R=I,I=R.field,r=R.query||r,e=R.limit||e,o=R.enrich||o),f)f[g]=this.index[I].searchAsync(r,e,R||t);else{if(s?w=s[g]:w=this.index[I].search(r,e,R||t),K=w&&w.length,l&&K){const D=[];let N=0;u&&(D[0]=[w]);for(let O=0,j,_;O<l.length;O++)j=l[O],(K=(_=this.l[j])&&_.length)&&(N++,D[D.length]=u?[_]:_);N&&(w=u?ds(D,e||100,p||0):Wn(w,D),K=w.length)}if(K)a[d]=I,n[d++]=w;else if(u)return[]}}if(f){const g=this;return new Promise(function(w){Promise.all(f).then(function(I){w(g.search(r,e,t,I))})})}if(!d)return[];if(i&&(!o||!this.store))return n[0];for(let g=0,w;g<a.length;g++){if(w=n[g],w.length&&o&&(w=gs.call(this,w)),i)return w;n[g]={field:a[g],result:w}}return n};function Bn(r,e,t,s){let n=this.l[r],a=n&&n.length-t;if(a&&0<a)return(a>e||t)&&(n=n.slice(t,t+e)),s&&(n=gs.call(this,n)),{tag:r,result:n}}function gs(r){const e=Array(r.length);for(let t=0,s;t<r.length;t++)s=r[t],e[t]={id:s,doc:this.store[s]};return e}G.contain=function(r){return!!this.register[r]};G.get=function(r){return this.store[r]};G.set=function(r,e){return this.store[r]=e,this};G.searchCache=ps;G.export=function(r,e,t,s,n,a){let i;if(typeof a>"u"&&(i=new Promise(o=>{a=o})),n||(n=0),s||(s=0),s<this.h.length){const o=this.h[s],c=this.index[o];e=this,setTimeout(function(){c.export(r,e,n?o:"",s,n++,a)||(s++,n=1,e.export(r,e,o,s,n,a))})}else{let o,c;switch(n){case 1:o="tag",c=this.l,t=null;break;case 2:o="store",c=this.store,t=null;break;default:a();return}ys(r,this,t,o,s,n,c,a)}return i};G.import=function(r,e){if(e)switch(te(e)&&(e=JSON.parse(e)),r){case"tag":this.l=e;break;case"reg":this.m=!1,this.register=e;for(let s=0,n;s<this.h.length;s++)n=this.index[this.h[s]],n.register=e,n.m=!1;break;case"store":this.store=e;break;default:r=r.split(".");const t=r[0];r=r[1],t&&r&&this.index[t].import(r,e)}};us(We.prototype);var jn={encode:fs,F:!1,G:""};const zn=[$("[]"),"a",$("[]"),"e",$("[]"),"i",$("[]"),"o",$("[]"),"u",$("[]"),"y",$(""),"n",$("[c]"),"k",$(""),"s",$(" & ")," and "];function fs(r){var e=r=""+r;return e.normalize&&(e=e.normalize("NFD").replace(On,"")),is.call(this,e.toLowerCase(),!r.normalize&&zn)}var Hn={encode:ms,F:!1,G:"strict"};const Gn=/[^a-z0-9]+/,qt={b:"p",v:"f",w:"f",z:"s",x:"s",:"s",d:"t",n:"m",c:"k",g:"k",j:"k",q:"k",i:"e",y:"e",u:"o"};function ms(r){r=fs.call(this,r).join(" ");const e=[];if(r){const t=r.split(Gn),s=t.length;for(let n=0,a,i=0;n<s;n++)if((r=t[n])&&(!this.filter||!this.filter[r])){a=r[0];let o=qt[a]||a,c=o;for(let l=1;l<r.length;l++){a=r[l];const u=qt[a]||a;u&&u!==c&&(o+=u,c=u)}e[i++]=o}}return e}var Vn={encode:ws,F:!1,G:""};const Jn=[$("ae"),"a",$("oe"),"o",$("sh"),"s",$("th"),"t",$("ph"),"f",$("pf"),"f",$("(?![aeo])h(?![aeo])"),"",$("(?!^[aeo])h(?!^[aeo])"),""];function ws(r,e){return r&&(r=ms.call(this,r).join(" "),2<r.length&&(r=et(r,Jn)),e||(1<r.length&&(r=os(r)),r&&(r=r.split(" ")))),r||[]}var Yn={encode:Xn,F:!1,G:""};const $n=$("(?!\\b)[aeo]");function Xn(r){return r&&(r=ws.call(this,r,!0),1<r.length&&(r=r.replace($n,"")),1<r.length&&(r=os(r)),r&&(r=r.split(" "))),r||[]}ke["latin:default"]=Pn;ke["latin:simple"]=jn;ke["latin:balance"]=Hn;ke["latin:advanced"]=Vn;ke["latin:extra"]=Yn;const Qn={Index:we,Document:We,Worker:Re,registerCharset:function(r,e){ke[r]=e},registerLanguage:function(r,e){ls[r]=e}},Zn=Qn.Index;async function Bt(r){let e=await z(r)||null||null;return e==null&&(e={items:{}}),e}async function ea(r,e){return W(r,e)}const ce=class ce{constructor(e,t){A(this,"name");A(this,"options");A(this,"index");this.name="idx_v1_"+e,this.options=t}static async getInstance(e,t={tokenize:"full"}){if(!ce._instanceLookup[e]){const s=new ce(e,t);await s.init(),ce._instanceLookup[e]=s}return ce._instanceLookup[e]}static async isAwake(e){return!!ce._instanceLookup[e]}async init(){const e=Date.now(),t=await Bt(this.name);y("IDX init: Timer RUN SEARCH 0",Date.now()-e),this.index=new Zn(this.options),await this._loadItems(Object.values(t.items)),y("IDX init: Timer RUN SEARCH 1",Date.now()-e)}async SEARCH(e,t=null){return this.index.search(e,t)}async QUERY(e,t=null){return await this.index.search(e,500,t)}async _loadItems(e){return await Promise.all(e.map(t=>this.index.add(t._id,Object.values(t))))}async PUT(e,t){const s=Date.now();y("IDX PUT: Timer RUN SEARCH 0",Date.now()-s),await this._loadItems(e),y("IDX PUT: Timer RUN SEARCH 1",Date.now()-s);const n=await Bt(this.name);console.log("indexData",n);for(const a of e)n.items[a._id]=a;await ea(this.name,n),y("IDX PUT: Timer RUN SEARCH 2",Date.now()-s)}async FLUSH(){y("IDX FLUSHING",this.name),delete ce._instanceLookup[this.name],await Oe(this.name)}};A(ce,"_instanceLookup",{});let it=ce;async function ta(r){return await it.isAwake(r)}async function jt(r,e={}){return await it.getInstance(r,e)}class Is{constructor(e,t){A(this,"_storeKey");A(this,"_idx",null);A(this,"_id");this._storeKey=e+"_"+t,this._id=t,this._idx=null}async updateStatus(e){await(await Fe.getInstance(this._id)).addProgress(e)}async reset(){this._idx=null,await Oe(this._storeKey)}async getIndex(){return this._idx||(this._idx=await z(this._storeKey)||{}),this._idx}async saveIndex(e){this._idx=e,await W(this._storeKey,e)}async updateIdx(e){throw new Error("Not Implemented")}async getMatches(e){const t=await this.getIndex();if(e.length<3)return t[e];const s=e.endsWith("s")?e.slice(0,-1):e,n=e.endsWith("s")?e:e+"s";let a=[];return s in t&&(a=a.concat(t[s])),n in t&&(a=a.concat(t[n])),a}}class me extends Is{constructor(e){super("REMOVEDITEMS_Lookup",e)}static getInstance(e){return new me(e)}async updateIdx(e){const t=await this.getIndex();for(const s of e)t[s]=!0;await this.saveIndex(t)}async removeItemIds(e){const t=await this.getIndex();for(const s of e)delete t[s];await W(this._storeKey,t)}async getMatchesForIds(e){const t=await this.getIndex();return e.map(s=>s in t)}async matches(e,t=!0){if(!e)return[];const s=await this.getIndex();return e.filter(n=>n in s==t)}async returnInIndex(e){return await this.matches(e,!0)}async returnNotInIndex(e){return await this.matches(e,!1)}}class Se extends Is{async filterOutRemovedIds(e){return await me.getInstance(this._id).returnNotInIndex(e)}async getRemovedIds(e){return await me.getInstance(this._id).returnInIndex(e)}async clearIdsFromRemoved(e){return await me.getInstance(this._id).removeItemIds(e)}}class ut extends Se{async getIndex(){const e=await z(this._storeKey)||{};return new _n(e)}async updateIdx(e){throw new Error("Not Implemented")}async getMatches(e,t=!1){const n=(await this.getIndex()).getMatches(e,t);return await this.filterOutRemovedIds(n)}async getExactMatchesForMultiple(e){const t=await this.getIndex(),s=[];for(const n of e){const a=t.getExactMatches(n),i=await this.filterOutRemovedIds(a);i&&i.length>0&&s.push({url:n,matches:i})}return s}}class ks extends Se{constructor(t,s,n={}){super(t,s);A(this,"options");this.options=n}async reset(){const t=this._storeKey;await(await jt(t,this.options)).FLUSH()}async getMatches(t){throw new Error("not implemented")}async getIndex(){const t=this._storeKey;return await jt(t,this.options)}async isAwake(){return await ta(this._storeKey)}}const sa=r=>{if(!r)return null;let t=new URL(r).hostname;t.startsWith("www.")&&(t=t.slice(4));const s=t.split(".").slice(-1)[0];return["com","org","net","edu","info","gov","io","me","ai"].includes(s)&&(t=t.split(".").slice(-2).join(".")),t};function xt(r){var e,t;try{return(e=r==null?void 0:r.details)!=null&&e.subType?(t=r==null?void 0:r.details)==null?void 0:t.subType.split("_"):null}catch{return null}}function ot(r){let e=[];try{if(r){const t=new URL(r).hostname,s=t.split(".");if(e.push(t),s.length>1){const n=s.slice(0,s.length-1);e.push(n.join(".")),s.length>2&&(e.push(s.slice(1).join(".")),e.push(n.slice(1).join(".")))}}}catch{console.error("Error extracting hostname",r)}return e}const Et=new Set(["name","title","description","keywords","url"]),Ne=new Set(["title","tags","name","description","url"]);class na extends ks{constructor(e){super("itemsearch",e,{tokenize:"full"})}async updateIdx(e){var n,a,i;let t=null;await this.clearIdsFromRemoved(e.map(o=>o.itemId)),t=await this.getIndex();const s=[];for(const o of e)try{const c=((n=o==null?void 0:o.details)==null?void 0:n.type)=="note"?["note","notes"]:null,l=xt(o),u=pe(o.details,Ne),p={...pe((a=o.details)==null?void 0:a.meta,Et),...u,_id:o.itemId,itemType:c,subType:l,hostnames:ot((i=o==null?void 0:o.details)==null?void 0:i.url)};s.push(p)}catch{console.error("Error adding item to search index",o.details._id,o.details.name)}s.length>0&&await t.PUT(s,{stopwords:es}),this.updateStatus(.25)}async getMatches(e,t=!1){const s=Date.now();if(!e||e=="")return[];e=e.trim().replace(/  +/g," "),y("IDX: Timer RUN SEARCH 0",Date.now()-s);const n=await this.getIndex();y("IDX: Timer RUN SEARCH 1",Date.now()-s);let a=await this.searchWithPlain(n,e.toLowerCase());return y("IDX: Timer RUN SEARCH 2",Date.now()-s),y("IDX: Search Results:",e,a),y("IDX: Timer RUN SEARCH 3",Date.now()-s),a.length==0?[]:await this.filterResults(a)}async filterResults(e){const t=new Set(await this.getRemovedIds(e.map(s=>s._id)));return e.filter(s=>!t.has(s._id))}async searchWithPlain(e,t){let s=await e.QUERY(t);return s=s.filter(n=>!!n).map(n=>({_id:n,_relScore:1,_matchScore:1})),s}async searchWithTokens(e,t,s="OR"){return(await e.QUERY({[s]:t,SCORE:"TFIDF",SORT:!0})).map(i=>{var o,c;return{...i,_relScore:i._score||((o=i._match)==null?void 0:o.length),_matchScore:((c=i._match)==null?void 0:c.length)||0}})}async wakeUp(){await this.getIndex()}async isAwake(){return await this.getIndex()}async getMatchesAuto(e){if(!e||e=="")return[];e=e.trim().replace(/  +/g," ");const t=await this.getIndex();let s=[];const n=await t.SEARCH(e);return s.push(...n),s.slice(0,10)}}class aa extends Se{constructor(e){super("TIMEINDEX",e)}async updateIdx(e){await this.clearIdsFromRemoved(e.map(i=>i.itemId));const t=await this.getIndex();t.latest=t.latest||[],t.latestTimes=t.latestTimes||{};const s=Object.fromEntries(e.map(i=>{var o;return[i.itemId,Date.parse((o=i==null?void 0:i.details)==null?void 0:o.createdAt)]})),n={...t.latestTimes,...s},a=Object.entries(n).map(([i,o])=>({itemId:i,timestamp:o}));a.sort(function(i,o){if(o.timestamp){if(!i.timestamp)return 1}else return-1;return o.timestamp-i.timestamp}),t.latestTimes=Object.fromEntries(a.slice(0,100).map(i=>[i.itemId,i.timestamp])),t.latest=a.slice(0,100).map(i=>i.itemId),await W(this._storeKey,t),this.updateStatus(.1)}async getMatches(e){const s=(await this.getIndex())[e];return s?await this.filterOutRemovedIds(s):[]}}class ra extends ks{constructor(e){super("collectionsearch",e,{tokenize:"strict",preset:"memory"})}async updateIdx(e){var o;let t=null;await this.clearIdsFromRemoved(e.map(c=>c.itemId)),t=await this.getIndex();const s=[],n=new Set;for(const c of e)c.details.type=="col"&&(s.push(c),n.add(c.itemId));y("IndexUpdate: collectionsList",s,n.size);const a={};for(const c of e){if(!c.collectionIds)continue;const u={...pe(c.details,Ne).tags,hostnames:ot((o=c==null?void 0:c.details)==null?void 0:o.url)};for(const p of c.collectionIds){const d=a[p]||[];d.push(u),a[p]=d}}const i=[];try{for(const c of s){let l=a[c.itemId];l&&l.length>7&&(l=l.sort(()=>Math.random()-.5).slice(0,7));let u=null;l&&l.length>0&&(u=l.map(d=>Object.values(d).join(" ")));const p=pe(c.details,Ne);i.push({...p,dR1:p.name+" "+p.name+" "+p.description,tR1:p.tags,_id:c.itemId,itemData:u})}}catch(c){console.error("error",c)}y("IndexUpdate: collectionDocs",i,a),i.length>0&&await t.PUT(i,{stopwords:es}),this.updateStatus(.2)}async getMatches(e){if(!e||e=="")return[];e=e.trim().replace(/  +/g," ");const t=await this.getIndex();let s=e.split(" ").map(o=>o.trim().toLowerCase()).filter(o=>o&&o.length>0),a=(await t.QUERY(s.join(" "),{suggest:!0,limit:40})).map(o=>({_id:o,_relScore:1,_matchScore:1}));const i=new Set(await this.getRemovedIds(a.map(o=>o._id)));return a.filter(o=>!i.has(o._id))}}class ia extends Se{constructor(e){super("VISIT",e)}async updateIdx(e){y("SIndex: Updating visit index",e),await this.clearIdsFromRemoved(e.map(d=>d.itemId));const t=e.filter(d=>{var f;return((f=d==null?void 0:d.feedback)==null?void 0:f.visitTime)!=null}).map(d=>({itemId:d.itemId,timestamp:Date.parse(d.feedback.visitTime),count:d.feedback.visitCount})),s=new Set(e.map(d=>d.itemId)),n=await this.getIndex();let{mostVisitedItemsOrig:a=[],recentlyVisitedItemsOrig:i=[]}=n;a=a.filter(d=>!s.has(d.itemId)),i=i.filter(d=>!s.has(d.itemId));const o=[...t,...i].sort(function(d,f){if(f.timestamp){if(!d.timestamp)return 1}else return-1;return f.timestamp-d.timestamp}).slice(0,100),c=o.map(d=>d.itemId),l=[...t,...a].sort(function(d,f){if(f.count){if(!d.count)return 1}else return-1;return f.count-d.count}).slice(0,20),u=l.map(d=>d.itemId),p={latest:c,most:u,mostVisitedItemsOrig:l,recentlyVisitedItemsOrig:o};y("SIndex: Updating visit index: newidx",p),await this.saveIndex(p),this.updateStatus(.1)}async appendIds(e){const t=await this.getIndex(),s=t?t.latest.filter(n=>e.indexOf(n)==-1):[];t.latest=[...e,...s],await this.saveIndex(t)}async getMatches(e){const t=await super.getMatches(e);return await this.filterOutRemovedIds(t)}}class oa extends Se{constructor(e){super("ATTRINDEX_Lookup",e)}async updateIdx(e){var s,n;await this.clearIdsFromRemoved(e.map(a=>a.itemId));let t=await this.getIndex();t.YOUTUBE_CHANNEL=t.YOUTUBE_CHANNEL||{},t.DOMAINS=t.DOMAINS||{};for(const a of e){const i=(s=a.details)==null?void 0:s.meta;if(i&&i.THETASET_PAGE_TYPE==Pe.YOUTUBE_CHANNEL){const o=((n=i.tsExtractedInfo)==null?void 0:n.youtubeChannelIds)||[];for(const c of o)t.YOUTUBE_CHANNEL[c]=a.itemId}if(a.details&&a.details.url)try{const o=sa(a.details.url);if(o){const c=t.DOMAINS[o]||[];c.push(a.itemId),t.DOMAINS[o]=c}}catch{}}await this.saveIndex(t),this.updateStatus(.05)}async getAttrValues(e){const s=(await this.getIndex())[e]||null;return s||[]}async getMatches(e,t){const n=(await this.getIndex())[e][t]||null;return n?await this.filterOutRemovedIds([n]):[]}async remove(e,t){const s=await this.getIndex();delete s[t][e],await this.saveIndex(s)}}class ca extends Se{constructor(e){super("itemData",e)}async getIndex(){return await ss.getInstance("itemData",this._storeKey,1)}async updateIdx(e){console.log("updateIdx",e),await this.clearIdsFromRemoved(e.map(n=>n.itemId));const t=await this.getIndex(),s=e.map(n=>({id:n.itemId,data:JSON.stringify(n)}));await t.put(s),await t.close(),this.updateStatus(.15)}async listWhere(e){const t=await this.getIndex(),s=await t.listWhere(e);return await t.close(),s}async listAll(){const e=await this.getIndex(),t=await e.listAll();return await e.close(),t.map(n=>JSON.parse(n.data))}async deleteIds(e){const t=await this.getIndex();await t.deleteWhereIds(e),await t.close()}async getItemsWithIds(e){const t=await this.getIndex(),s=await this.filterOutRemovedIds(e),n=await t.listById(s);return await t.close(),n.map(i=>JSON.parse(i.data))}async reset(){const e=await this.getIndex();await e.clearStore(),await e.close()}}class la extends ut{constructor(e){super("URLINDEX_ITEM_Lookup",e)}async updateIdx(e){var s,n,a;await this.clearIdsFromRemoved(e.map(i=>i.itemId));const t=await this.getIndex();for(const i of e)try{if(!i.details){console.error("Error Reading details",i);continue}if(i.details.encrypted&&!i.details.decrypted){console.error("failed to decrypt",i);continue}try{const o=new Set;if((s=i==null?void 0:i.details)!=null&&s.patterns)for(const l of i.details.patterns)o.add(l);if((n=i==null?void 0:i.details)!=null&&n.url&&o.add(It(i.details.url)),(a=i==null?void 0:i.info)!=null&&a.additionalLinks)for(const l of i.info.additionalLinks)t.add(i.itemId,[It(l.url)]);let c=Array.from(o);c.length>0&&t.add(i.itemId,c)}catch{console.error("Error adding item to search index",i._id,i.name)}}catch{console.error("Error adding item to search index",i._id,i.name)}await W(this._storeKey,t.lookup),this.updateStatus(.05)}}class ua extends ut{constructor(e){super("CONTENTINDEX_Lookup",e)}async updateIdx(){const e=await this.getIndex(),t=[{key:"youtube.com",patterns:[It("www.youtube.com")]}];for(const s of t)e.add(s.key,s.patterns);await W(this._storeKey,e.lookup),this.updateStatus(.05)}async getMatches(e){return(await this.getIndex()).getMatches(e)}}class da extends Se{constructor(e){super("TAGINDEX_Lookup",e)}async updateIdx(e){await this.clearIdsFromRemoved(e.map(s=>s.itemId));const t=await this.getIndex();for(const s of e)if(!(!s||!s.details||!s.details.tags))try{for(const n of s.details.tags){if(n==null||n.length==0)continue;let a=t[n];a==null&&(a=[]),a.push(s.itemId),t[n]=a}}catch{console.error("Error adding tag",s._id,s.name)}await this.saveIndex(t),this.updateStatus(.05)}async getItemTags(){const e=await this.getIndex();return Object.keys(e)}}class pa extends ut{constructor(t){super("URLINDEX_PLUGIN_Lookup",t);A(this,"_pluginLookupKey");this._pluginLookupKey="PLUGIN_Lookup"}async updateIdx(t){await this.reset();const s=await z(this._pluginLookupKey)||{},n=await this.getIndex();for(const a of t)n.add(a._id,a.patterns),s[a._id]=a;await W(this._storeKey,n.lookup),await W(this._pluginLookupKey,s),this.updateStatus(.05)}async getMatches(t){const s=await this.getIndex(),n=await z(this._pluginLookupKey);return s.getMatches(t).map(i=>n[i])}}class ya extends ut{constructor(e,t="URLINDEX_TEMP_Lookup"){super(t,e)}async updateIdx(e,t=!1){const s=await this.getIndex();t&&this.reset();for(const n of e)try{try{s.add(n.sourceId,n.patterns)}catch{}}catch{console.error("Error adding item to search index",n)}await W(this._storeKey,s.lookup)}}const de=class de{constructor(e){A(this,"idx_id");A(this,"itemDataIdx");A(this,"urlIdx");A(this,"urlTempIdx");A(this,"ctxIdx");A(this,"tagIdx");A(this,"pluginIdx");A(this,"attributeIdx");A(this,"visitIdx");A(this,"timeIdx");A(this,"collectionIdx");A(this,"itemSearchIdx");A(this,"itemTableDB");this.idx_id=e,this.itemDataIdx=new ca(e),this.urlIdx=new la(e),this.urlTempIdx=new ya(e),this.ctxIdx=new ua(e),this.tagIdx=new da(e),this.pluginIdx=new pa(e),this.attributeIdx=new oa(e),this.visitIdx=new ia(e),this.timeIdx=new aa(e),this.collectionIdx=new ra(e),this.itemSearchIdx=new na(e)}static async getInstance(e){return(!de._instance||de._instance.idx_id!=e)&&(de._instance=new de(e)),de._instance}async updateIndex(e,t=!1){console.log("Initializing Data Index, fullreset=",t);const s=await Fe.getInstance(this.idx_id);await s.startBuild();try{t&&await this.reset(),await this._updateIndex(e)}catch(n){console.error(n)}finally{return await s.endBuild()}}async reset(){await me.getInstance(this.idx_id).reset(),await this._updateDefault(),await Promise.all([this.urlIdx.reset(),this.tagIdx.reset(),this.attributeIdx.reset(),this.timeIdx.reset(),this.visitIdx.reset(),this.itemSearchIdx.reset(),this.collectionIdx.reset(),this.itemDataIdx.reset(),this.urlTempIdx.reset()])}async _updateIndex(e){const{updatedItems:t,removedItemIds:s}=e;s.length>0&&(await me.getInstance(this.idx_id).updateIdx([...s]),await this.itemDataIdx.deleteIds(s)),await Promise.all([this.urlIdx.updateIdx(t),this.tagIdx.updateIdx(t),this.attributeIdx.updateIdx(t),this.timeIdx.updateIdx(t),this.visitIdx.updateIdx(t),this.itemSearchIdx.updateIdx(t),this.collectionIdx.updateIdx(t),this.itemDataIdx.updateIdx(t)])}async updatePlugins(){const e=await k.remoteRequest("/user/plugin/list");await this.pluginIdx.updateIdx(e)}async _updateDefault(){await this.updatePlugins(),await this.ctxIdx.updateIdx()}};A(de,"_instance");let bt=de;const ft=1,zt=new ct;class C{static async getChangeLog(e){let{fullReset:t,updatedItems:s,removedItemIds:n,totalUpdates:a}=await S.remoteRequestEncryptionWrapper("/changeLog/sync",{userId:e.userId,lastUpdate:e.lastUpdate});return s=s.filter(i=>{var o,c;return!!((o=i==null?void 0:i.details)!=null&&o.decrypted)||!((c=i==null?void 0:i.details)!=null&&c.encrypted)}),{fullReset:t,updatedItems:s,removedItemIds:n,totalUpdates:a}}static async getDataIndex(e=null){return e||(e=await m.getCurrentUserId()),bt.getInstance(e)}static async getDataIndexStatus(e=null){return e||(e=await m.getCurrentUserId()),Fe.getInstance(e)}static async updateDataIndex(e=!1,t=!1,s=!1){y("DEBUG: updateDataIndex:",e,t,s),await zt.acquire();try{if(!await H.isActive())return y("Not active connection, not building index"),!1;const n=await m.getCurrentUser(t);return n?await this._updateDataIndex(n,e,s):(await H.isActive()&&(y("No Current user, resetting connection"),await H.reset()),!1)}catch(n){return console.error("Error updating index",n),!1}finally{zt.release()}}static async _updateDataIndex(e,t=!1,s=!1){y("SIndex: Running index update request, force=",t,e);let n=t;const a=e.updatedAt?new Date(e.updatedAt):new Date,i=`indexInfo_${e._id}`,o=await z(i)||{},c={lastUpdate:void 0,lastFullReset:void 0,updateCount:0,currentUserId:void 0,indexVersion:void 0,fullResetComplete:!1,...o};(!c.lastFullReset||o.currentUserId!=e._id||c.indexVersion!=ft||!c.fullResetComplete)&&(n=!0);const l=c!=null&&c.lastUpdate&&!n?new Date(c==null?void 0:c.lastUpdate):null;if(!n&&l&&l>=a)return y("SIndex: update not needed:",{localLastUpdate:l,actualLastUpdate:a,needFullreset:n,indexInfo:c,currentTime:new Date}),!1;y("SIndex: update request",{localLastUpdate:l,actualLastUpdate:a,needFullreset:n,indexInfo:c});const{fullReset:u,updatedItems:p,removedItemIds:d,totalUpdates:f}=await C.getChangeLog({userId:e._id,lastUpdate:l});y("SIndex: Total Updates in batch:",{totalUpdates:f,fullReset:u,updatedItems:p,removedItemIds:d});const g=n||u;if(y("SIndex: isFullReset = ",g),f==0&&!u)return y("SIndex: No updates, skipping"),c.lastUpdate=a.toJSON(),c.updateCount=c.updateCount+1,c.currentUserId=e._id,c.indexVersion=ft,await W(i,c),!1;const w=await C.getDataIndex(e._id);if(await(await C.getDataIndexStatus(e._id)).isBuilding())if(s)y("SIndex: Index is building, but overrideExistingRun is true, so continuing");else return y("SIndex: Index is already building, skipping update"),!1;return g&&await W(i,{indexInfoData:{...c,fullResetComplete:!1}}),console.log("SIndex: Starting Index Update",{isFullReset:g,updatedItems:p,removedItemIds:d}),await w.updateIndex({updatedItems:p,removedItemIds:d},g)?(c.lastUpdate=a.toJSON(),c.updateCount=c.updateCount+1,c.currentUserId=e._id,c.indexVersion=ft,g&&(c.fullResetComplete=!0,c.lastFullReset=a.toJSON(),c.updateCount=0),y(`SIndex: reset isFullReset=${g} complete index`,c),await W(i,c),!0):(y("SIndex: update failed"),!1)}static async updatePlugins(){y("Updating plugins"),await(await C.getDataIndex()).updatePlugins()}}const V=[];V.push({path:"/client/signin",handler:async(r,e,t)=>await m.signIn(e)});V.push({path:"/client/switchUser",handler:async(r,e,t)=>await m.switchUser(e.userId,e.pinpass)});V.push({path:"/client/register",handler:async(r,e,t)=>await m.register(e,(t==null?void 0:t.backupKeyOnServer)==!0)});V.push({path:"/client/tokenLogin",handler:async(r,e,t)=>await m.tokenSignIn(e.token)});V.push({path:"/signout",handler:async(r,e,t)=>await H.reset()});V.push({path:"/client/resetPassword",handler:async(r,e,t)=>await m.resetPassword(e)});V.push({path:"/client/updatePassword",handler:async(r,e,t)=>await m.updatePassword(e)});V.push({path:"/client/updatePIN",handler:async(r,e,t)=>await m.updatePIN(e.userId,e.pin)});V.push({path:"/client/auth/permissionOverride",handler:async(r,e,t)=>await m.permissionOverride(e)});V.push({path:"/authInfo",handler:async(r,e,t)=>{var s;return(s=await H.getAuthInfo())==null?void 0:s.tokenData}});V.push({path:"/authInfo/get",handler:async(r,e,t)=>await H.getAuthInfo()});V.push({path:"/client/updatePlugins",handler:async(r,e,t)=>await C.updatePlugins()});V.push({path:"/user/options/get",handler:async(r,e,t)=>await m.getUserOptions(e==null?void 0:e.userId,e==null?void 0:e.refresh)});V.push({path:"/client/currentUser",handler:async(r,e,t)=>await m.getCurrentUser(e.refresh)});V.push({path:"/user/currentUser/delete",handler:async(r,e,t)=>{const s=await k.remoteRequest("/user/delete",{userIdToDelete:await m.getCurrentUserId()});console.log("Delete Response...",s),await m.signOut()}});V.push({path:"/clientSettings/get",handler:async(r,e,t)=>await m.getUserClientSettings(e==null?void 0:e.userId)});V.push({path:"/clientSettings/save",handler:async(r,e,t)=>await m.saveUserClientSettings(e)});V.push({path:"/client/auth/createUser",handler:async(r,e,t)=>await m.createUser(e)});V.push({path:"/client/serverSettings/update",handler:async(r,e,t)=>{e.enableServerSettings?await Rs(e.serverSettings):await Us()}});V.push({path:"/client/serverSettings/refresh",handler:async(r,e,t)=>await Zt(!0)});V.push({path:"/client/serverSettings/get",handler:async(r,e,t)=>await As()});async function ha(r,e,t,s){const{user:n,acnt:a}=await h.generateUserKeyBundleForNewAccount(r,e,t,s),i=await h.serializedKeyMapToKeyEntries(n),o=await h.serializedKeyMapToKeyEntries(a),c=i.concat(o),l=await ee.instanceFromPassword(r,e,t,s,c);return await l.load(),{keyManager:l,keyEntries:c}}function mt(r){return JSON.parse(JSON.stringify(r))}async function ga(){const r="a_123",e="testsalt",{keyManager:t}=await ha("u_123",r,"abc123782934",e),s=Date.now(),n={name:{type:"string",encrypted:!0},description:{type:"string",encrypted:!0},meta:{type:"object",encrypted:!0}},a={_id:"123",name:"Test name",description:"Tests ",meta:{title:"titleStuff's  "}};let i={};const o=mt(a);i.dataToEncrypt=o;const c=await t.encryptObjectWithKeyIds(t.getAcntSecretKeyId(),a,n);i.encResult=mt(c);const l=await t.decryptObject(c.obj,n,c.encInfo);i.decResult=mt(l);let u=!0;for(const d of["name","description"])n[d]&&n[d].encrypted&&(console.log("Comparing",d,o[d],l[d]),o[d]!=l[d]&&(u=!1,console.log("Failed",d,o[d],l[d])));for(const d of["meta"])n[d]&&n[d].encrypted&&(console.log("Comparing",d,o[d],l[d]),JSON.stringify(o[d])!=JSON.stringify(l[d])&&(u=!1,console.log("Failed",d,o[d],l[d])));const p=Date.now();return console.log("time encrypt/descript some stuff: ",p-s),{success:u,info:i}}class wt{constructor(e){A(this,"_storeKey");A(this,"_id");const t="visitHistory";this._id=e,this._storeKey=t+"_"+e}async getIndex(){return await ss.getInstance("visitHistory",this._storeKey,1)}async updateIdx(e){const t=await this.getIndex(),s=e.map(n=>({id:n.id,data:n}));await t.put(s),await t.close()}async listWhere(e){const t=await this.getIndex(),s=await t.listWhere(e);return await t.close(),s}async deleteById(e){const t=await this.getIndex();await t.deleteWhereIds(e),await t.close()}async getEntriesByIds(e){const t=await this.getIndex(),s=await t.listById(e);return await t.close(),s}async reset(){const e=await this.getIndex();await e.clearStore(),await e.close()}}async function Le(r,e){E.appType=="ios"?Rt.sendAppRequest({action:"UPDATE_TAB",value:{options:e,tabId:r}}):chrome.tabs.update(r,e)}function Me(r){return E.appType=="ios"?"capacitor://localhost"+r:chrome.runtime.getURL(r)}const fa=r=>{if(E.appType=="ios")Rt.sendAppRequest({action:"INSERT_CSS",value:{details:r}});else{let e=()=>{chrome.runtime.lastError?console.error("Sentry: Error inserting CSS: ",chrome.runtime.lastError.message,r.files," TabId:",r.target.tabId):y("Sentry: CSS injected successfully")};chrome.scripting.insertCSS(r,e)}},ma=r=>{if(E.appType=="ios")Rt.sendAppRequest({action:"EXECUTE_SCRIPT",value:{details:r}});else{let e=()=>{chrome.runtime.lastError?console.error("Sentry: Error injecting JS:",chrome.runtime.lastError.message,r.files," TabId:",r.target.tabId):y("Sentry: JS injected successfully",r.files)};const t=chrome.runtime.getManifest().manifest_version;if(console.log("MANIFEST VERSION: ",t),t>=3)chrome.scripting.executeScript(r,e);else for(let s of r.files)y("EXECUTING SCRIPT FILE: ",s,r.target),chrome.scripting.executeScript({target:r.target,files:[s]},e)}},Te=new ct,Xe=new ct,wa=1e3*30,Ia=1e3*60*10,Ht=1;class b{static amKey(e){return`activityMon_${e._id}`}static searchKey(e){return`searchMon_${e._id}`}static async getActivityMonitorFromStorage(e){return await z(e)}static async clearActivityMonitor(e){return await Oe(e)}static async _saveActivityMonitor(e,t){return await W(e,t)}static _newMonitor(e="active"){return{monitorId:js(),lastSync:0,log:[],type:e,activeLog:{},createdAt:Date.now(),updatedAt:Date.now(),schemaVer:Ht}}static async _getUsageLogsSinceRemote(e,t=null,s=!1){const n=await m.getCurrentUserId();t||(t=n);const a=`usageLogCache_${t}`,i=Date.now()-1e3*60*15;if(!s){const l=await z(a);if(l&&l.timestamp>=i)return l.usageLogs}const o=await S.remoteRequestEncryptionWrapper("/user/activity/loglist",{userId:t,options:{createdAt:e}}),c=(o==null?void 0:o.userActivityLog)||[];return await W(a,{timestamp:Date.now(),usageLogs:c}),c}static async _getUsageLogEntriesSinceRemote(e,t=null,s=!1){var o;const n=new Date(e.getTime()-864e5),a=await b._getUsageLogsSinceRemote(n,t,s);let i=[];for(const c of a){const l=(o=c==null?void 0:c.data)==null?void 0:o.log;l&&i.push(...l)}return i}static async _getUsageLogEntiesSince(e,t,s){var a;const n=t?qs(t):[];for(const i of s)if(!(t&&(t==null?void 0:t.monitorId)==i.monitorId)){const o=(a=i==null?void 0:i.data)==null?void 0:a.log;if(o){const c=o.map(l=>(l.monitorId=i.monitorId,l));n.push(...c)}}return n}static async _hasTimeLeft(e){const{defaultTimeLimit:t,defaultTimeUsage:s,defaultTimeLeft:n,defaultTimeExceeded:a,contentUsage:i}=e;if(a)return!0;for(const o of i)if(o.limitExceeded)return!0}static async _checkTimeLeft(e,t){const s=Ae(1),n=await b._getUsageLogsSinceRemote(s),a=await b._getUsageLogEntiesSince(s,e,n),i=Ae(0),o=yt(a,i.getTime(),null),c=await b._getUsageSummary(o,t);return y("Time Left Info:",c),await b._hasTimeLeft(c)}static async _getUsageSummary(e,t,s=null){var g;const n=Dt(e),a=new Date().getDay(),{usageLimitData:i,timeLimitSettings:o}=await b._getUsageLimitsData(s);console.log("Usage Limit Data:",i);const c=[];for(const w of i.defaultUsageLimits||[])w.timeLimit.daysOfWeek.includes(a)&&c.push(w);const l=[];for(const w of i.contentUsageLimits||[])if(w.timeLimit.daysOfWeek.includes(a)){if(!t)l.push(w);else if(w.type=="urlPatterns"){const I=((g=w==null?void 0:w.data)==null?void 0:g.patterns)||[];for(const K of I)if(t.includes(K)){l.push(w);break}}}let u=0;o&&o.extraTimeExpires>Date.now()&&(u=o.extraTimeDefault*60*1e3);const p=[];for(const w of l){const I=Bs(e,w.data.patterns);if(I.length>0){const K=Dt(I),R=w.timeLimit.hours*(1e3*60*60)+u-K;p.push({limit:w,usage:K,extraTimeMS:u,timeLeft:R,limitExceeded:R<=0})}else p.push({limit:w,usage:0,extraTimeMS:u,timeLeft:w.timeLimit.hours*(1e3*60*60)+u,limitExceeded:!1})}const d=c.length>0?Math.max(...c.map(w=>w.timeLimit.hours))*60*60*1e3:null,f=d?d+u-n:null;return{defaultTimeLimit:d,defaultTimeUsage:n,defaultTimeLeft:f,defaultTimeExceeded:f!=null&&f<=0,defaultExtraTimeMS:u,contentUsage:p}}static async _getUsageLimitsData(e){let t=await m.getUserOptions(e);const s=t.usageLimitsData||{};(s==null?void 0:s.version)!=1;const n=t.timeLimitSettings||{};return(!n.extraTimeExpires||Date.now()>n.extraTimeExpires)&&(n.defaultExtraTime=0),{usageLimitData:s,timeLimitSettings:n}}static async _sync(e,t,s){const n=Date.now();if(!(s||n-t.lastSync>Ia&&t.updatedAt>t.lastSync))return y("Not syncing activity monitor, not enough time has passed or no updates"),!1;const i=[...t.log];for(const u of Object.keys(t.activeLog))i.push(t.activeLog[u]);const c=new Date().getDate()!=new Date(t.createdAt).getDate();if(await S.remoteRequestEncryptionWrapper("/user/activity/push",{monitorId:t.monitorId,createdAt:t.createdAt,updatedAt:t.updatedAt,type:t.type,data:{log:i},complete:c}))c?t=b._newMonitor("active"):t.lastSync=Date.now(),await b._saveActivityMonitor(e,t);else throw new Error("Failed to sync activity monitor")}static async clearUsageLog(e,t,s){const n=t==null?void 0:t.userId;if(n)return await k.remoteRequest("/user/activity/clearUsageLog",{userId:n});{const a=await m.getCurrentUser();if(!a)return[];const i=b.amKey(a);return await b.clearActivityMonitor(i),await k.remoteRequest("/user/activity/clearUsageLog")}}static async clearEntry(e,t,s){const{userId:n,monitorId:a,key:i}=t;if(n)return await k.remoteRequest("/user/activity/clearUsageLog",{userId:n});{const o=await m.getCurrentUser();if(!o)return[];const c=b.amKey(o);return await b.clearActivityMonitor(c),await k.remoteRequest("/user/activity/clearUsageLog")}}static async _getUsageLogsSince(e){const t=e==null?void 0:e.userId;let s=new Date(e.createdAt);const n=await m.getCurrentUser();if(!n)return[];if(!t||n._id==t){const a=b.amKey(n);let i=await b.getActivityMonitorFromStorage(a);y("Activity Monitor:",i);let o=await b._getUsageLogsSinceRemote(s,null,!0);return await b._getUsageLogEntiesSince(s,i,o)}else return await b._getUsageLogEntriesSinceRemote(s,t,!0)}static async getUsageLogsSince(e,t,s){return await b._getUsageLogsSince({userId:t==null?void 0:t.userId,createdAt:t.createdAt})}static async update(e,t,s){var c,l,u;const n=await m.getCurrentUser();if(!n)return{success:!1};const a=b.amKey(n),{sender:i}=s,o=Date.now();await Te.acquire();try{let p=await b.getActivityMonitorInstance(a);const{type:d,url:f,events:g}=t,w=(c=i==null?void 0:i.tab)==null?void 0:c.id,I=`${w}_${d}_${f}`;y("Event Key: ",I),p.updatedAt=o;let K=p.activeLog[I],R=!1;if(K&&o-K.endTime>wa&&(p.log.push(K),delete p.activeLog[I],R=!0,y("Creating new entry")),R||!K?K={type:d,url:f,startTime:o,endTime:o+1e3,contextId:w}:K.endTime=o,p.activeLog[I]=K,y("Activity Monitor:",p),await b._checkTimeLeft(p,f)){const N=(u=(l=s.sender)==null?void 0:l.tab)==null?void 0:u.id;y("Exceeded Limit",N),E.appType=="ios"?await Le(i.tab.id,{url:Me("/index.html#/outOfTime?url="+encodeURIComponent(f))}):chrome.tabs.update(N,{url:chrome.runtime.getURL("/index.html#/outOfTime?url="+encodeURIComponent(f))})}await b._saveActivityMonitor(a,p),await b._sync(a,p,!1)}catch(p){console.error("Activity Monitor Error",p)}finally{Te.release()}return{success:!0}}static async getActivityMonitorInstance(e){let t=await b.getActivityMonitorFromStorage(e);return(!t||(t==null?void 0:t.schemaVer)!=Ht)&&(t=b._newMonitor("active")),t}static async recordVisit(e){const t=await m.getCurrentUser();if(!t)return{success:!1};const s=b.amKey(t),n=Date.now();try{await Te.acquire();let a=await b.getActivityMonitorInstance(s);a.log.push(e),a.updatedAt=n,await b._saveActivityMonitor(s,a),await b._sync(s,a,!1)}catch(a){console.error("Activity Monitor Error",a)}finally{Te.release()}return{success:!0}}static async getCurrentUsageSummary(e,t,s){const n=t==null?void 0:t.userId,a=Ae(1),i=Ae(0),o=await m.getCurrentUser();if(!o)return null;if(!n||o._id==n){const c=b.amKey(o);let l=await b.getActivityMonitorFromStorage(c);const u=await b._getUsageLogsSinceRemote(a),p=await b._getUsageLogEntiesSince(a,l,u),d=yt(p,i.getTime()),f=await b._getUsageSummary(d,t.urlFilter),g=await b._hasTimeLeft(f);return{timeLeftInfo:f,timeExceeded:g}}else{const c=await b._getUsageLogEntriesSinceRemote(a,n),l=yt(c,i.getTime()),u=await b._getUsageSummary(l,t.urlFilter,n),p=await b._hasTimeLeft(u);return{timeLeftInfo:u,timeExceeded:p}}}static async sync(e){await Te.acquire();try{const t=await m.getCurrentUser();if(!t)return;const s=b.amKey(t),n=await b.getActivityMonitorFromStorage(s);if(!n)return;await b._sync(s,n,e)}finally{Te.release()}}static async visitHistoryForURLs(e){return null}static async listUserActivity(e){return await S.remoteRequestEncryptionWrapper("/user/activity/list",e)}static async logVisit(e){return await S.remoteRequestEncryptionWrapper("/user/logVisit",e)}static async logCollectionVisit(e){return await S.remoteRequestEncryptionWrapper("/user/logCollectionVisit",e)}static async updateVisitIndex(e){await Xe.acquire();try{const t=await m.getCurrentUserId(),s=new wt(t),n=dt(e),a={url:e,lastVisit:Date.now(),visitCount:1,timespend:0};await s.updateIdx([{id:n,data:a}])}finally{Xe.release()}}static async getVisitInfoForURLs(e){const t=await m.getCurrentUserId(),s=new wt(t),n=e.map(dt);return await s.getEntriesByIds(n)}static async buildVisitHistoryIndex(){await Xe.acquire();try{const e=Ae(30),t=await b._getUsageLogsSince({createdAt:e.getTime()}),s={};for(const i of t){const o=dt(i.url);let c=s[o];if(c){let l=c.visitCount||0;const u=i.endTime-c.lastVisit;if(u>0){const p=u>3e4?1:0;s[o]={url:i.url,lastVisit:i.endTime,visitCount:l+p}}}else s[o]={url:i.url,lastVisit:i.endTime,visitCount:1}}const n=await m.getCurrentUserId();await new wt(n).updateIdx(Object.entries(s).map(([i,o])=>({id:i,data:{url:o.url,lastVisit:o.lastVisit,visitCount:o.visitCount,timespend:0}})))}finally{Xe.release()}}}at.addSignoutCallback(()=>{b.sync(!0)});class Z{static async uploadUserFile(e,t=!1){const{encInfo:s}=e;let n=e;if(s!=null){const a=await m.getUserRequestContext();n=(await(await T.getKeyManager(a)).encryptObjectUsingEncInfo(s,e,{fileData:{encrypted:!0,type:"string"}})).obj}else if(t&&!s){const a=await m.getUserRequestContext(),i=await T.getKeyManager(a);n=(await i.encryptOrReencryptObject([i.getAcntSecretKeyId()],e,{fileData:{encrypted:!0,type:"string"}})).obj}return await k.remoteRequest("/userfile/upload",n)}static async decryptUserFileWithId(e){const{data:t,userFile:s}=await Z.getUserFileById({id:e},!0);if(s!=null&&s.encInfo){let n=s,a={ufId:n._id,fileData:t,refId:n.refId,refType:n.refType,filename:n.filename,fileType:n.fileType,encInfo:null};await Z.uploadUserFile(a)}}static async encryptUserFileWithId(e,t=null){const{data:s,userFile:n}=await Z.getUserFileById({id:e},!0);if(!n.encInfo){let a=n,i={ufId:a._id,fileData:s,refId:a.refId,refType:a.refType,filename:a.filename,fileType:a.fileType,encInfo:t};await Z.uploadUserFile(i,!0)}}static async getUserFileByIdStream(e,t=!1){const s=await k.remoteRequestRaw("/userfile/getById",e);y("getUserFileById",e,s);const a=(await s.text()).split(Ns),i=a[0],o=a[1],c=i,l=JSON.parse(o),u=await m.getUserRequestContext(),p=await T.getKeyManager(u);if(y("getUserFileById jsonObject",l,c),!l.encInfo)return t==!0?{data:c,userFile:l}:c;const d=await p.decryptObject({data:JSON.stringify(c)},{data:{encrypted:!0,type:"string"}},l.encInfo);return t==!0?{data:d.data,userFile:l}:d==null?void 0:d.data}static createResultFileObject(e,t,s){if(s.appendDataPrefix&&!e.startsWith("data:"))if(t.fileType){let n=Cs(t.fileType);n.startsWith("plain")||(e=`data:${n};base64,${e}`)}else s.defaultPrefix&&(e=`data:${s.defaultPrefix},${e}`);return s.includeUserFileData==!0?{data:e,userFile:t}:e}static async getUserFileById(e,t=!1,s=!1,n=null){const i=await(await k.remoteRequestRaw("/userfile/getById",e)).json();if(!(i!=null&&i.results))throw new Error("User file not found");const{userFile:o,fileDataBase64:c}=i.results,l=c;let u=l;if(o.encInfo){const p=await m.getUserRequestContext(),f=await(await T.getKeyManager(p)).decryptObject({data:JSON.stringify(l)},{data:{encrypted:!0,type:"string"}},o.encInfo);u=f==null?void 0:f.data}return this.createResultFileObject(u,o,{appendDataPrefix:s,defaultPrefix:n,includeUserFileData:t})}}function le(r){let e="";for(let t of r)t!=null&&(t=t.trim(),t!=null&&t.length>e.length&&(e=t));return e}function ka(r){return r.includes("youtube.com/c/")||r.includes("youtube.com/channel/")||r.includes("youtube.com/@")||r.includes("youtube.com/user/")}async function Sa(r,e,t,s){const n=ka(t),a=n?Pe.YOUTUBE_CHANNEL:Pe.YOUTUBE_PAGE;s.pageType=a;const i=e('span[itemprop="author"] link[itemprop="url"]').attr("href"),o=i!=null?await Gt(i):null;o&&(s.youtubeChannelIds=[o]);const c=await Ea(e,"externalChannelId");if(c.length==1&&s.youtubeChannelIds.push(c[0]),n){const l=e('link[rel="alternate"][media="handheld"]');l.length>0&&console.error("Multiple matches for link[rel='alternate'][media='handheld']");const u=l.attr("href"),p=u!=null?await Gt(u):null;p&&s.youtubeChannelIds.includes(p)==!1&&s.youtubeChannelIds.push(p)}return s}async function Ka(r,e){const t={},s={pageType:null,youtubeChannelIds:[],message:null};try{const n=zs(e),a=n("meta[itemProp],meta[name],meta[property],link[href]").toArray();for(const i of a)if("content"in i.attribs){let o=null;i.attribs.itemprop?o=i.attribs.itemprop:i.attribs.name?o=i.attribs.name:i.attribs.property&&(o=i.attribs.property),o&&(t[o]=i.attribs.content)}t.title=n("title").text(),r.includes("youtube.com")&&(await Sa(t,n,r,s),t.THETASET_PAGE_TYPE=s.pageType)}catch(n){s.message="ERROR: "+n}return t.tsExtractedInfo=s,t}const Ta=/\/(channel|c|user)\/?([^\/]+)\/?.*/,xa=/\/@([^\/]+)(\/?.*)/;async function Gt(r){let e=r.match(Ta),t=e?e[2]:null;return t||(e=r.match(xa),t=e?e[1]:null),t}async function Ea(r,e="canonicalBaseUrl"){const t=new Set,s=new RegExp(`"${e}":"(.*?)"`,"g");return r("script").each(function(){const n=r(this).html();if(!n)return;let a;for(;(a=s.exec(n))!==null;)t.add(a[1])}),Array.from(t)}async function ba(r,e){const t=await Ka(r,e);let s={};return s.url=r,s.title=le([t.title,t["og:title"],t["og:site_name"]]),s.description=le([t.description,t["og:description"]]),s.keywords=le([t.keywords,t["og:keywords"]]),s.siteName=le([t["og:site_name"]]),s.type=le([t["og:type"]]),s.locale=le([t["og:locale"]]),s.imageSrc=le([t["og:image"]]),s.THETASET_PAGE_TYPE=t.THETASET_PAGE_TYPE,s.favicon=le([t["shortcut icon"],t.icon,t["apple-touch-icon"],t["apple-touch-icon-precomposed"]]),s.tsManifest={version:2},s.tsExtractedInfo=t.tsExtractedInfo,s}async function Ra(r,e={}){return new Promise((t,s)=>{Ut(r,{timeout:8e3,...e}).then(n=>{if(n.status!==200){const a="Looks like there was a problem. Status Code: "+n.status+", for URL:"+r;return y(a),s(a)}n.text().then(async a=>{const i=await ba(r,a);if(y("META",i),chrome.runtime.lastError)return s(chrome.runtime.lastError);t(i)})}).catch(n=>(y("Fetch Error :-S",r,n),s(n)))})}class Q{static async getImagesFromMetaData(e,t){let s=new URL(e);const n=[t==null?void 0:t.bannerImageURL,t==null?void 0:t.imageSrc,t==null?void 0:t.googleFaviconSrcPath,t==null?void 0:t.faviconSrcPath].filter(a=>!!a).map(a=>!a.startsWith("http")&&a.startsWith("/")?s.origin+a:a);return console.log("Image sources",n),await Q.getImageFromSourceURLS(n)}static async getImageFromSourceURLS(e){console.log("Image sources",e);for(let t of e){console.log("Trying to load image",t);try{let s;try{s=await Ds(t)}catch(a){console.error("Failed to load image directly from src",a)}if(!s)try{console.error("Failed to load image directly from src, trying proxy");let a="/userdata/proxy?url="+encodeURIComponent(t);s=await(await k.remoteRequestRaw(a,{},{method:"GET"})).blob()}catch(a){throw console.error("Failed to load image from proxy",a),a}if(!s){console.error("Failed to load image, skipping");continue}return{image:await vs({imageBlob:s,maxSize:800,quality:.7}),imageSrc:t}}catch(s){console.error("Failed to load metadata, image ",t,s)}}return{image:null,imageSrc:null}}static async getImageFromURL(e){}static async refreshItemMetaIfNeeded(e){if(!e.url)return!1;e.meta&&e.meta.resolved;const{meta:t}=await Q.getMetaAndBannerByURL(e.url,{force:!1,skipBanner:!0});if(!t)return!1;let s={meta:t,encInfo:e.encInfo};return await S.remoteRequestEncryptionWrapper("/item/update",{itemId:e._id,data:s}),!0}static async updateMetaDataForItem(e,t=!1){if(!e.url)return!1;const{meta:s,image:n}=await Q.getMetaAndBannerByURL(e.url,{force:t,skipBanner:!1});return s?(y("MetaData refreshed",s,e),await Q.saveMetaAndImage(e._id,e.encInfo,s,n),!0):!1}static async saveMetaAndImage(e,t,s,n){let a={meta:s,encInfo:t};if(n){let{fileData:i,fileType:o}=_s(n);const c=await Z.uploadUserFile({refId:e,refType:"item",fileType:o,encInfo:t,filename:"banner",fileData:i,secure:!0});await Ls("imageCache",c),a.imageFilename="uf_"+c}await S.remoteRequestEncryptionWrapper("/item/update",{itemId:e,data:a})}static async refreshItemMetaDataForItemIds(e,t=!1){const s=await S.remoteRequestEncryptionWrapper("/item/byIds",{ids:e});console.log("Items",s);for(const n of s)try{await Q.updateMetaDataForItem(n,t)}catch(a){console.error("Failed to update meta",n,a)}return!0}static async getDataByURL(e){if(y("getMetaByURL, browser_mode:",E.browser_mode),E.browser_mode)throw new Error("Not implemented");{const t=await Ut(e,{timeout:8e3});if(!t.ok)return{base64Data:null};const s=t.headers.get("content-type");return{base64Data:await Ms(await t.blob(),!1),mimeType:s}}}static async getMetaByURL(e){return y("getMetaByURL, browser_mode:",E.browser_mode,e),E.browser_mode?await k.remoteRequest("/item/meta/fetch",{url:e}):await Q.getMetaByURLForExtension(e)}static async getMetaAndBannerByURL(e,t={skipBanner:!1}){let s=await Q.getMetaByURL(e);if(!s)return{meta:null,image:null};if(t.skipBanner)return{meta:s,image:null};const{image:n,imageSrc:a}=await Q.getImagesFromMetaData(e,s);return s.bannerImageSrcPath=a,{meta:s,image:n}}static async getMetaByURLForExtension(e){y("Fetch for extension",e);const t=await Ra(e).catch(s=>{console.error("Metadata fetch failed",s),Promise.resolve(null)});return t!=null&&(t.resolved=!0),t}static async getMetaByURLForExtensionWithAxios(e){y("Fetch for extension axios",e);const t=await fetchRawMetaBrowserAxios(e).catch(s=>{console.error("Metadata fetch failed axios",s),Promise.resolve(null)});return t!=null&&(t.resolved=!0),t}}function xe(r){const e={};return e.name=r.name,e.description=r.description,e.comment=r.comment,e.meta=r.meta,e.info=r.info,e.tags=r.tags,e.key=r.key,e.url=r.url,e.patterns=r.patterns,e}class v{static async remoteClientFetch(e){return E.browser_mode&&E.appType!="ios"?await k.remoteRequestRaw("/userdata/proxyr",{url:e,type:"json"}):await fetch(e)}static async getWikiImagesWithQuery(e,t=1){try{let n=`https://commons.wikimedia.org/w/api.php?action=query&format=json&generator=search&gsrsearch=${encodeURIComponent(e)}&gsrlimit=${t}&gsrnamespace=6&prop=imageinfo&iiprop=url`;const o=(await(await v.remoteClientFetch(n)).json()).query.pages;let c=[];for(const l in o)if(o.hasOwnProperty(l)){const d=o[l].imageinfo[0].url;c.push(d)}return c}catch(s){return console.error("Error getting wiki images",s),[]}}static async saveItem(e,t=null){var l,u,p,d;let s=!(e!=null&&e.itemId);y("Saving item",e,s);let n=(l=e==null?void 0:e.details)==null?void 0:l.url,a=(u=e==null?void 0:e.details)!=null&&u.meta?{...(p=e==null?void 0:e.details)==null?void 0:p.meta}:null,{result:i,sentData:o}=await S.remoteRequestEncryptionWrapper("/item/save",e,{includeSentDataInResult:!0});y("Saved itemId",i,o);let c=(d=o==null?void 0:o.details)==null?void 0:d.encInfo;return(t==null?void 0:t.dontBlockForMeta)==!0?v.getItemMetadata(s,n,t,e,a,i,c):await v.getItemMetadata(s,n,t,e,a,i,c),(t==null?void 0:t.includeEncInfo)==!0?{itemId:i,encInfo:c}:i}static async getItemMetadata(e,t,s,n,a,i,o){var c,l;if(e&&(t||n.bannerQuery)&&(s==null?void 0:s.skipMetaFetch)!=!0)if((c=n==null?void 0:n.details)!=null&&c.imageFilename&&a)y("we dont need anything");else if(!((l=n==null?void 0:n.details)!=null&&l.imageFilename)&&a){y("Getting image from meta data, don't have image filename yet");const u=await Q.getImagesFromMetaData(t,a),{image:p,imageSrc:d}=u;a.imageSrc=d,await Q.saveMetaAndImage(i,o,a,p)}else if(n.bannerQuery){y("Getting image from meta data, don't have image filename yet"),y("Getting image from wiki",n.bannerQuery);const u=await v.getWikiImagesWithQuery(n.bannerQuery);if(y("Got image from wiki",u),u.length>0){let p=await Q.getImageFromSourceURLS([u[0]]);const{image:d,imageSrc:f}=p;a||(a={}),a.imageSrc=f,await Q.saveMetaAndImage(i,o,a,d)}}else{let{meta:u,image:p}=await Q.getMetaAndBannerByURL(t,{skipBanner:!1});console.log("Meta ",u),u&&await Q.saveMetaAndImage(i,o,u,p)}C.updateDataIndex()}static async createCollection(e){let t=await S.remoteRequestEncryptionWrapper("/collection/create",e);return C.updateDataIndex(),t}static async getItem(e){return await S.remoteRequestEncryptionWrapper("/item/infoById",e)}static async getUserItemsWithInfo(e,t=!0){if(!e||e.length==0)return[];const s=await C.getDataIndex();let n=await s.itemDataIdx.getItemsWithIds(e);const a=new Set(n.map(i=>i.itemId));if(e.length!=a.size){y("getUserItemsWithInfo: Retrieved items don't match requested items, fetching missing items",e.length,a.size);const i=e.filter(o=>!a.has(o));if(y("Missing ids",i),i.length>0){const o=await S.remoteRequestEncryptionWrapper("/item/listWithInfoByUser",{ids:i});o.length>0&&await s.itemDataIdx.updateIdx(o),n=await s.itemDataIdx.getItemsWithIds(e)}}return t||(n=n.filter(i=>i.details.type!="col")),n}static async encryptItems(e){const{itemIds:t}=e,s=await m.getCurrentUser();if(s.type!="admin")throw new Error("Only admins can encrypt all items.  You are: "+s.type);const n=await m.getUserRequestContext();if((await T.encStatus(n,!1)).userEncSetup!=!0)throw new Error("User encryption not setup");const i=await this.getItemsWithInfo({ids:t}),o=new Date().getTime();for(const c of i){const l=c.details;if(l.encrypted==!0){if(l.imageFilename&&l.imageFilename.startsWith("uf_")){const u=l.imageFilename.replace("uf_","");await Z.encryptUserFileWithId(u,l.encInfo)}continue}try{const u=xe(l),{sentData:p}=await S.remoteRequestEncryptionWrapper("/item/update",{itemId:c.itemId,data:u},{forceEncrypt:!0,includeSentDataInResult:!0});if(l.imageFilename&&l.imageFilename.startsWith("uf_")){const d=l.imageFilename.replace("uf_","");await Z.encryptUserFileWithId(d,p.encInfo)}}catch(u){throw console.error("Error encrypting:",l,u),u}}y("Total time:",new Date().getTime()-o)}static async getItemsWithInfo(e={}){const t=e.userId||await m.getCurrentUserId(),s=e.ids&&e.ids.length>0?e.ids:null;return await S.remoteRequestEncryptionWrapper("/item/listWithInfoByUser",{userId:t,ids:s,includeAllCollections:!0})}static async collectionListByUser(e){var i;const{includePath:t,includeParents:s}=e,n=await S.remoteRequestEncryptionWrapper("/collection/listByUser",e);y("collectionListByAccount results",[...n]);const a={type:"array",encryptedChildren:!0,properties:{name:{type:"string",encrypted:!0}}};if(t){const o=[];for(const u of n)u.details.pathItems&&u.details.pathItems.length>0&&o.push(...u.details.pathItems);const c=await S.decryptData("include path",o,a);y("includePath decItems",c);const l=Object.fromEntries(c.map(u=>[u._id,u]));for(const u of n)u.details.pathItems&&(u.details.path=u.details.pathItems.map(p=>l[p._id].name))}if(s){const o={type:"array",encryptedChildren:!0,properties:X},c=[];for(const p of n)p.details&&((i=p.details)==null?void 0:i.parents.length)>0&&c.push(...p.details.parents);const l=await S.decryptData("include parents",c,o);y("includeParents decItems",l);const u=Object.fromEntries(l.map(p=>[p._id,p]));for(const p of n)p.parents&&(p.parents=p.parents.map(d=>u[d._id].name))}return n}static async collectionListByAccount(e){const{includePath:t}=e,s=await S.remoteRequestEncryptionWrapper("/collection/listByAccount",e);y("collectionListByAccount results",[...s]);const n={type:"array",encryptedChildren:!0,properties:{name:{type:"string",encrypted:!0}}};if(t){const a=[];for(const c of s)c.pathItems.length>0&&a.push(...c.pathItems);const i=await S.decryptData("include path",a,n);y("decItems",i);const o=Object.fromEntries(i.map(c=>[c._id,c]));for(const c of s)c.path=c.pathItems.map(l=>o[l._id].name)}return y("collectionListByAccount",s),s}static async collectionItems(e){return await S.remoteRequestEncryptionWrapper("/collection/listItemsWithInfoByUser",e)}static async addItemAttachment(e){const{itemId:t,attachmentInfo:s,encInfo:n}=e;if(s.type=="file"){const i=(d=>d.replace(/[^a-z0-9]/gi,"_").toLowerCase())(s.filename);let o=s.imagePreview?[{data:s.imagePreview,id:"0",type:s.imageType||"jpeg"}]:null,c={refId:t,refType:"item",fileType:s.fileType,encInfo:n,filename:i,fileData:s.fileData,previews:o},l=await Z.uploadUserFile(c),u=o?o.map(d=>({id:d.id,type:d.type})):null,p={id:i,filename:s.filename,type:"file",meta:s.meta,fileType:s.fileType,previews:u,fileId:l};await S.remoteRequestEncryptionWrapper("/item/attachment/add",{itemId:t,attachment:p})}else throw new Error("Not implemented")}static async decryptCollection(e){var l,u,p;const t=await m.getCurrentUser();if(t.type!="admin")throw new Error("Only admins can decrypt items.  You are: "+t.type);const s=await m.getUserRequestContext();if((await T.encStatus(s)).userEncSetup!=!0)throw new Error("User encryption not setup");const a=await S.remoteRequestEncryptionWrapper("/collection/infoByUser",e),i=xe(a);i.encInfo={decrypt:!0};const o=a.imageFilename;if(o&&o.startsWith("uf_")){const d=o.replace("uf_","");await Z.decryptUserFileWithId(d)}await k.remoteRequest("/item/update",{itemId:e.collectionId,data:i,allowDecrypt:!0});const c=await this.collectionItems(e);for(const d of c){const f=(l=d.details)==null?void 0:l.imageFilename;if(f&&f.startsWith("uf_")){const I=f.replace("uf_","");await Z.decryptUserFileWithId(I)}const g=(u=d.details)==null?void 0:u.attachments;if(g!=null&&g.entries)for(const I of g.entries)I.fileId&&await Z.decryptUserFileWithId(I.fileId);if(((p=d.details)==null?void 0:p.encInfo)!=null){const I=xe(d.details);I.encInfo={decrypt:!0},I.encrypted=!1,await k.remoteRequest("/item/update",{itemId:d.itemId,data:I,allowDecrypt:!0})}else y("Not encrypted? for item",d);const w=d.collectionRelation;w!=null&&w.encrypted&&(w.encInfo={decrypt:!0},w.encrypted=!1,await k.remoteRequest("/collection/itemDetails/save",{itemId:d.itemId,collectionId:a._id,details:w.details,encInfo:{decrypt:!0}}))}}static async decryptItems(e){var c;const{itemIds:t}=e,s=await m.getCurrentUser();if(s.type!="admin")throw new Error("Only admins can encrypt all items.  You are: "+s.type);const n=await m.getUserRequestContext();if((await T.encStatus(n)).userEncSetup!=!0)throw new Error("User encryption not setup");const i=await v.getItemsWithInfo({ids:t}),o=new Date().getTime();y("Decrypting items:",i);for(const l of i){const u=l.details;if(u.imageFilename&&u.imageFilename.startsWith("uf_")){const d=u.imageFilename.replace("uf_","");await Z.decryptUserFileWithId(d)}const p=(c=u.details)==null?void 0:c.attachments;if(p!=null&&p.entries)for(const d of p.entries)d.fileId&&await Z.decryptUserFileWithId(d.fileId);if(u.encInfo)try{const d=xe(u);d.encInfo={decrypt:!0},await k.remoteRequest("/item/update",{itemId:l.itemId,data:d,allowDecrypt:!0}),y("Decrypted:",u.name)}catch(d){throw console.error("Error encrypting:",u,d),d}}y("Total time:",new Date().getTime()-o)}static async encryptCollection(e){const t=await m.getCurrentUser();if(t.type!="admin")throw new Error("Only admins can encrypt items.  You are: "+t.type);const s=await m.getUserRequestContext();if((await T.encStatus(s)).userEncSetup!=!0){let c="User encryption not setup";throw console.error("EC: "+c),new Error(c)}const a=await S.remoteRequestEncryptionWrapper("/collection/infoByUser",e),i=xe(a);if(await S.remoteRequestEncryptionWrapper("/item/update",{itemId:e.collectionId,data:i},{forceEncrypt:!0}),a.imageFilename&&a.imageFilename.startsWith("uf_")){const c=a.imageFilename.replace("uf_","");await Z.encryptUserFileWithId(c)}const o=await this.collectionItems(e);for(const c of o)try{const l=c.details;if(l.imageFilename&&l.imageFilename.startsWith("uf_")){const d=l.imageFilename.replace("uf_","");await Z.encryptUserFileWithId(d)}const u=xe(l);l.encInfo||await S.remoteRequestEncryptionWrapper("/item/update",{itemId:c.itemId,data:u},{forceEncrypt:!0});const p=c.collectionRelation;p&&!p.encrypted&&await S.remoteRequestEncryptionWrapper("/collection/itemDetails/save",{itemId:c.itemId,collectionId:a._id,details:p.details},{forceEncrypt:!0})}catch(l){console.error("Error encrypting:",c.itemId,l)}}static async rediscoverQueue(e){let{userId:t,timeFrameDays:s=7,showReadLater:n=!1,showCollections:a=!1}=e;const i=await m.getCurrentUserId();if((t||i)!=i)throw new Error("Not implemented");const c=await C.getDataIndex(),l=60*60*24*s,u=new Date().getTime(),p=await c.itemDataIdx.listWhere(d=>{const f=d==null?void 0:d.details;if(!a&&(f==null?void 0:f.type)=="col")return!1;const g=d==null?void 0:d.feedback;if((g==null?void 0:g.archivedDate)!=null||(g==null?void 0:g.neverRemindDate)!=null)return!1;const w=(f==null?void 0:f.createdAt)||(f==null?void 0:f.updatedAt);if(g){if((g==null?void 0:g.isReadLaterDate)!=null&&!n)return!1;let I=new Date((g==null?void 0:g.lastVisit)||0).getTime()+l,K=new Date((g==null?void 0:g.snoozeUntilDate)||0).getTime(),R=Math.max(I,K);return d.sortTime=R,u-R>0}else if(w){const I=new Date(w).getTime()+l;return d.sortTime=I,u-I>0}else return!0});return p.sort((d,f)=>d.sortTime-f.sortTime),p.slice(0,200)}}class _e{static async testDB(e={}){const s=await(await C.getDataIndex()).itemTableDB.query("feedbackheart",["heart"]);return console.log("TABLE_DB Current table SEARCH:",s),{results:s}}static async cryptoTest1(e={}){return ga()}static async createItemAndRetrieve(e){const t=await v.saveItem(e),s=await v.getItem({itemId:t});await v.encryptItems({itemIds:[t]});const n=await v.getItem({itemId:t});let a=!0;const i=["name","description","url"];for(const o of i)s[o]!=n[o]&&(a=!1);return JSON.stringify(s.details.meta)!=JSON.stringify(n.details.meta)&&(a=!1),{success:a,info:{item:s,item2:n}}}static async visitHistoryIndexTest(e){return{success:!0,info:{result:await b.buildVisitHistoryIndex()}}}static async getIndex(e){return{success:!0,info:{index:await(await C.getDataIndex()).itemDataIdx.getIndex()}}}}let Ua={name:1.9,title:1.9,tags:1.5};function Ss(r,e){const t={};let s=ts();for(const p of r)s.has(p)||(t[p]=(t[p]||0)+1);const n=r.length,a={},{k1:i,b:o,avgDocLength:c,termDocFreq:l,numDocs:u}=e;for(const[p,d]of Object.entries(t)){const f=Math.log((u-(l[p]||0)+.5)/((l[p]||0)+.5)+1),g=d*(i+1)/(d+i*(1-o+o*(n/c)));a[p]=f*g}return a}async function Ks(r,e=1.5,t=.75,s={}){const n=r.length,a=r.reduce((o,c)=>o+c.tokens.length,0)/n;for(const o of r){const c=new Set(o.tokens);for(const l of c)s[l]=(s[l]||0)+1}return{k1:e,b:t,avgDocLength:a,termDocFreq:s,numDocs:n}}async function Ts(r,e){return r.map(s=>({doc:s,lookup:Ss(s.tokens,e)}))}async function Aa(r,e=1.5,t=.75,s={}){const n=await Ks(r,e,t,s);return{bm25Results:await Ts(r,n),bm25Info:n}}async function Vt(r,e,t,{exclusionIdSet:s}={exclusionIdSet:new Set}){let n=ts();return e=e.filter(a=>!n.has(a)),r.map((a,i)=>({score:e.reduce((c,l)=>{let u=t[i].lookup[l]||0;return c+u},0),doc:a})).filter(({score:a,doc:i})=>!s.has(i._id)).sort((a,i)=>i.score-a.score)}class L{static async searchMain(e){const t=e.searchType;let s=[];return t=="text"?s=await L.runSearch(e.searchLookupValue):t=="tags"?s=await L.getItemsWithTag(e.searchLookupValue):t=="collection"?s=await S.remoteRequestEncryptionWrapper("/client/collection/listItemsWithInfoByUser",{collectionId:e.searchLookupValue}):t=="time"?s=await L.getItemsByTimeIndex(e.searchLookupValue):t=="visit"?s=await L.getItemsByVisitIndex(e.searchLookupValue):t=="terms"?s=await L.getItemsBySeachTerm({type:e.searchLookupValue}):t=="domains"?s=await L.getItemsBySeachTermAndValue({type:"domains",value:e.searchLookupValue}):y("ERROR searchType unknown:",t),s}static getTokensFromString(e){return e.toLowerCase().split(" ").map(s=>s.trim()).filter(s=>s.length>1&&s.length<50&&s!="")}static sortLookupTokensByScore(e){return Object.keys(e).sort((t,s)=>e[s]-e[t])}static getTokensFromItem(e){var o,c;xt(e);const t=pe(e.details,Ne);t.tags=t.tags?t.tags.join(" "):null;const s=pe((o=e.details)==null?void 0:o.meta,Et)||{};let n=/[^a-zA-Z0-9]/g;return[...Object.values(t).filter(l=>l!=null).map(l=>l.replace(n," ").trim()).map(l=>l.split(" ")).flat(),...Object.values(s).filter(l=>l!=null).map(l=>l.replace(n," ").trim()).map(l=>l.split(" ")).flat(),...ot((c=e==null?void 0:e.details)==null?void 0:c.url)].map(l=>l.toLowerCase().trim()).filter(l=>l.length>1)}static prepareSingleItem(e){if(!e.details)return null;const t=L.getTokensFromItem(e);return{_id:e.itemId,item:e,tokens:t}}static async prepareDocuments(){const t=await(await C.getDataIndex()).itemDataIdx.listAll(),s=[];for(const n of t){const a=L.prepareSingleItem(n);a&&s.push(a)}return s}static async searchOnIndexSlow(e){const t=await L.prepareDocuments(),{bm25Results:s,bm25Info:n}=await Aa(t);let i=(await Vt(t,e,s)).filter(o=>o.score>0).map(o=>{let c=o.doc.item,l=o.score||0;return c.scoreInfo={_relScore:l},c});return i.sort((o,c)=>c.scoreInfo._relScore-o.scoreInfo._relScore),i}static async searchOnIndex(e){let t={};const s=await C.getDataIndex(),n=Date.now(),a=new Set,i=await s.itemDataIdx.listWhere(c=>{var l,u,p,d,f,g;try{if(!c.details)return!1;const w=xt(c),I=pe(c.details,Ne);c.collectionIds&&c.collectionIds.length>0&&c.collectionIds.forEach(F=>{F&&a.add(F)});const K={...pe((l=c.details)==null?void 0:l.meta,Et),...I,_id:c.itemId,itemType:c.details.type,subType:w,hostnames:ot((u=c==null?void 0:c.details)==null?void 0:u.url)};let R=0,D=0;for(const F in K)if(typeof K[F]=="string"){let se=0,je=K[F].toLowerCase(),ze=0;for(const He of e)if(je.includes(He)){let xs=He.length/je.length;se+=xs+3*ze,ze++}se>0&&(D++,R+=se*(Ua[F]||1))}if(D==0)return!1;let N=((p=c==null?void 0:c.feedback)==null?void 0:p.visitCount)||0,O=0;(d=c==null?void 0:c.feedback)!=null&&d.lastVisit&&typeof((f=c==null?void 0:c.feedback)==null?void 0:f.lastVisit)=="string"&&(O=new Date((g=c==null?void 0:c.feedback)==null?void 0:g.lastVisit).getTime(),O>n-24*60*60*1e3&&(N+=10));let j=1+2*(Math.log(N+1)/Math.log(2)),_=R/D*j;return t[c.itemId]=_,!0}catch(w){return console.error("error in searchOnIndex",w),!1}});let o={};if(a.size>0){let c=await s.itemDataIdx.getItemsWithIds(Array.from(a));o=Object.fromEntries(c.map(l=>[l.itemId,{_id:l.itemId,name:l.details.name,imageFilename:l.details.imageFilename}]))}for(const c of i)c.scoreInfo={_relScore:t[c.itemId]||0},c.collectionIds&&c.collectionIds.length>0&&(c.parentList=c.collectionIds.filter(l=>!!l).map(l=>o[l]));return i.sort((c,l)=>l.scoreInfo._relScore-c.scoreInfo._relScore),i}static stemTokens(e){return e.map(t=>t.length>3&&t.endsWith("s")?t.slice(0,t.length-1):t)}static getSearchStrings(e){if(!e||e.length<1)return[];e=e.trim().replace(/  +/g," ").toLowerCase(),(e.endsWith("collection")||e.endsWith("collections"))&&(e=e.replace("collection","").replace("collections","")),(e.endsWith("item")||e.endsWith("items"))&&(e=e.replace("item","").replace("items",""));let n=L.stemTokens(e.split(" ").filter(i=>i.length>0)),a=[];return a.push(...n),n.length>1&&a.push(n.join(" ")),a}static async getRelatedItemsForCollection(e){let t=await S.remoteRequestEncryptionWrapper("/collection/infoByUser",{collectionId:e});if(!t)return[];let s=await S.remoteRequestEncryptionWrapper("/collection/listItemsWithInfoByUser",{collectionId:e});const n=await L.prepareDocuments(),a=await Ks(n);let i=[t.name,t.description,t.tags?t.tags.join(" "):null].filter(R=>!!R).join(" ");const o=L.getTokensFromString(i),c=new Set([e,...s.map(R=>R.itemId)]);let l=[];for(const R of s)l.push(L.getTokensFromItem(R));let u=l.flat(),p=Ss(u,a),d=Object.fromEntries(Object.entries(p).filter(([R,D])=>D>3)),f=L.sortLookupTokensByScore(d).slice(0,10),g=[...o,...f];const w=await Ts(n,a);console.log("bm25Results",{bm25Info:a,bm25Results:w});let K=(await Vt(n,g,w,{exclusionIdSet:c})).filter(R=>R.score>4).map(R=>{let D=R.doc.item,N=R.score||0;return D.scoreInfo={_relScore:N},D});return console.log("scoredResults",K),K.sort((R,D)=>D.scoreInfo._relScore-R.scoreInfo._relScore),K}static async runSearch(e,t=!1){const s=Date.now(),n=L.getSearchStrings(e),a=await L.searchOnIndex(n);return y("Timer RUN SEARCH 1xx",Date.now()-s,a.length),a.slice(0,100)}static async runSearchAuto(e){e=e.replace("https://","").replace("http://","").replace("www.","").toLowerCase();const t=L.getSearchStrings(e),s=await L.searchOnIndex(t);y("AutoSearch: AUTO SEARCH AND MATCHES: ",e),y("AutoSearch: AUTO MATCHES results: ",s);const n=s.slice(0,30).map(p=>{var f,g,w;return[`${((f=p.details)==null?void 0:f.name)||((w=(g=p==null?void 0:p.details)==null?void 0:g.meta)==null?void 0:w.title)}`,p]}).filter(p=>!!p&&p[0].length>0);y("AutoSearch: AUTO MATCHES output: ",n);const a=new Set,i=n.map(p=>p[0]).filter(p=>{const d=p.trim().toLowerCase();return a.has(d)?!1:(a.add(d),!0)}).map(p=>p.toLowerCase().split(" ")).flat(),o=e.split(" "),c={},l=o[o.length-1];for(const p of i)p.startsWith(l)&&(c[p]=(c[p]||0)+1);const u=Object.keys(c).sort((p,d)=>c[d]-c[p]);if(y("AutoSearch: sortedTokens",u),o.length<=1)return[...u.slice(0,3).map(p=>[p]),...n];{const p=o.slice(0,o.length-1);return u.length>0&&p.push(u[0]),[[p.join(" ")],...n]}}static async runCollectionSearch(e){if(y("Suggestion search:",e),!e||e.length==0)return{};e=e.replace("https://","").replace("http://","").replace("www.","");const s=await(await C.getDataIndex()).collectionIdx.getMatches(e);y("Suggestion results ids:",s);const n=s.map(i=>i._id).slice(0,3),a=await v.getUserItemsWithInfo(n,!0);return y("col_suggestions results",a),a.map(i=>{const o=i.details;return{_id:o._id,name:o.name,data:o}})}static async getCollectionsRecent(){var t,s,n;const e=await m.getCurrentUser();if((t=e==null?void 0:e.userData)!=null&&t.collectionIdHistory&&((s=e==null?void 0:e.userData)==null?void 0:s.collectionIdHistory.length)>0)try{let a=(n=e==null?void 0:e.userData)==null?void 0:n.collectionIdHistory.slice(0,12),i=new Set;return a=a.filter(c=>i.has(c)?!1:(i.add(c),!0)),await v.getUserItemsWithInfo(a,!0)}catch(a){return console.error("error getting collections recent",a),[]}else return[]}static async getCollectionSuggestions(e,t){var l,u,p;if(y("col_suggestions suggestionQuery 1",e),(!e||e.length==0)&&(!t||t.length==0))return{};let s=[];const n=await C.getDataIndex();if(e&&(e=e.replace("https://","").replace("http://","").replace("www.",""),s=await n.collectionIdx.getMatches(e)),t){let f=new URL(t).hostname;s.push(...await n.collectionIdx.getMatches(f))}y("col_suggestions results ids",s);const a=s.map(d=>d._id).slice(0,6),i=await m.getCurrentUser();if((l=i==null?void 0:i.userData)!=null&&l.collectionIdHistory&&((u=i==null?void 0:i.userData)==null?void 0:u.collectionIdHistory.length)>0){const d=(p=i==null?void 0:i.userData)==null?void 0:p.collectionIdHistory.slice(0,8);for(const f of d.reverse()){const g=a.indexOf(f);g!=-1&&(a.splice(g,1),a.unshift(f))}}const o=i.quickBarCollectionId;if(o){const d=a.indexOf(o);d!=-1&&(a.splice(d,1),a.unshift(o))}const c=await v.getUserItemsWithInfo(a,!0);return y("col_suggestions results",c),c.map(d=>{const f=d.details;return{_id:f._id,name:f.name,data:f}})}static async getItemsWithTag(e){const t=await(await C.getDataIndex()).tagIdx.getMatches(e);if(!t||t.length==0)return[];const s=new Set,n=[];for(const i of t)s.has(i)||(s.add(i),n.push(i));return await v.getUserItemsWithInfo(n,!0)}static async getItemsByTimeIndex(e){const t=await(await C.getDataIndex()).timeIdx.getMatches(e),s=new Set,n=t.filter(i=>{const o=s.has(i);return s.add(i),!o});return await v.getUserItemsWithInfo(n,!0)}static async getItemsByVisitIndex(e){const t=await(await C.getDataIndex()).visitIdx.getMatches(e);y("SEARCH: VISIT INDEX: ",t);const s=new Set,n=t.filter(i=>{const o=s.has(i);return s.add(i),!o});return await v.getUserItemsWithInfo(n,!1)}static async getMatchesForURL(e){return await(await C.getDataIndex()).urlIdx.getMatches(e)}static async getExactMatchesForMultipleURLs(e){return await(await C.getDataIndex()).urlIdx.getExactMatchesForMultiple(e)}static async getItemsBySeachTerm(e){const{type:t}=e;if(t=="ytchannel"){y("Getting ytchannel items");const s=await(await C.getDataIndex()).attributeIdx.getAttrValues(Pe.YOUTUBE_CHANNEL);y("attributeData",s);const n=new Set(Object.values(s));return await v.getUserItemsWithInfo(Array.from(n),!0)}return[]}static async getItemsBySeachTermAndValue(e){const{type:t,value:s}=e;if(t=="domains"){y("Getting domain items");const a=(await(await C.getDataIndex()).attributeIdx.getAttrValues("DOMAINS"))[s];return await v.getUserItemsWithInfo(a,!0)}return[]}static async searchTerms(e){const{type:t}=e;if(t=="domains"){const s=await(await C.getDataIndex()).attributeIdx.getAttrValues("DOMAINS"),a=Object.keys(s).map(i=>({key:i,text:i,count:s[i].length}));return a.sort((i,o)=>i.text<o.text?-1:i.text>o.text?1:0),a}else if(t=="tags"){const s=await(await C.getDataIndex()).tagIdx.getIndex()||{},a=Object.keys(s).map(i=>({key:i,text:i,count:s[i].length}));return a.sort((i,o)=>i.text<o.text?-1:i.text>o.text?1:0),a}return[]}static async searchEmbedded(e,t,s){var a=(await Os({active:!0,currentWindow:!0}))[0];if(a){const i=await L.runSearch(t.searchText,!0);return[...(await Fs(t.searchText)).filter(l=>!(l.index==a.index&&l.windowId==a.windowId)),...kt(i)]}else return[]}static async listItemsWithFilter(e){let{userId:t,filter:s}=e;const n=await m.getCurrentUserId(),a=t||n;if(a!=n){if(s=="reactionDate")return await S.remoteRequestEncryptionWrapper("/items/listWithFeedback",{userId:a,feedbackType:"reactionDate"});if(s=="isHidden")return await S.remoteRequestEncryptionWrapper("/items/listWithFeedback",{userId:a,feedbackType:"isHidden"});throw new Error("Not implemented")}const i=await C.getDataIndex();if(s=="isHidden")return await S.remoteRequestEncryptionWrapper("/items/listWithFeedback",{userId:a,feedbackType:"isHidden"});if(s=="reactionDate")return await i.itemDataIdx.listWhere(c=>{var l;return((l=c==null?void 0:c.feedback)==null?void 0:l.reactionDate)!=null});if(s=="isReadLaterDate")return await i.itemDataIdx.listWhere(c=>{var l;return((l=c==null?void 0:c.feedback)==null?void 0:l.isReadLaterDate)!=null});if(s=="isReadDate")return await i.itemDataIdx.listWhere(c=>{var l;return((l=c==null?void 0:c.feedback)==null?void 0:l.isReadDate)!=null});if(s=="starredDate")return await i.itemDataIdx.listWhere(c=>{var l;return((l=c==null?void 0:c.feedback)==null?void 0:l.starredDate)!=null});if(s=="all")return await i.itemDataIdx.listWhere(c=>!0);throw new Error("Not implemented for filter: "+s)}static async similarItemsByURL(e){const{url:t,itemId:s=null}=e;if(!t)return{exactMatches:[],similarMatches:[]};let n=[],a=[],i=(await L.getMatchesForURL(t)).filter(l=>l!=s);if(i.length==0)return{exactMatches:n,similarMatches:a};const o=await v.getUserItemsWithInfo(i,!1),c=pt(t);return n=o.filter(l=>pt(l.details.url)==c&&l.itemId!=s),a=o.filter(l=>pt(l.details.url)!=c&&l.itemId!=s),{exactMatches:n,similarMatches:a}}static async getExactMatchesForURLs(e){const{urls:t}=e;let s=await L.getExactMatchesForMultipleURLs(t),n=[],a=s.map(c=>c.matches).flat();const i=await v.getUserItemsWithInfo(a,!1);let o={};for(const c of i)o[c.itemId]=c;for(const c of s){const{url:l,matches:u}=c;if(u.length==0)continue;let p=o[u[0]];n.push({url:l,item:p})}return n}static async getMatchesByPublishIds(e){const{pubIds:t}=e,s=new Set(t),a=await(await C.getDataIndex()).itemDataIdx.listWhere(o=>{if(s.has(o.details.publishId))return!0});let i=[];for(const o of a)i.push({pubId:o.details.publishId,item:o});return i}}async function Ca(r){let e=Hs(r),t=[],s=[],n=[],a=[];e(".g .yuRUbf h3").each((o,c)=>{t[o]=e(c).text()}),e(".yuRUbf a").each((o,c)=>{s[o]=e(c).attr("href")}),e(".g .VwiC3b ").each((o,c)=>{n[o]=e(c).text()}),e(".g .yuRUbf .NJjxre .tjvcx").each((o,c)=>{a[o]=e(c).text()});const i=[];for(let o=0;o<t.length;o++)i[o]={title:t[o],links:s[o],snippet:n[o],displayedLink:a[o]};return y(i),i}function Jt(r,e){return new Promise(t=>{chrome.runtime.onMessage.addListener(function s(n,a,i){a.tab.id==e&&n.type==r&&(chrome.runtime.onMessage.removeListener(s),t(n))})})}function Da(r=!1){return`
You are an LLM AI agent performing tasks for an app named 'Kindredly' which let users create a personal library 
of items like links, notes, etc, and sort them into collections. Users can also comment on 
each item and share these items with people on their account. You have capabilities to search 
within the app data, update it, aid with tasks, and interact with the user. The app is also a browser extension 
so  you can interact with the browser.

Instructions:
Keep your responses succinct and do not ask unnecessary questions. Take autonomous decisions on the 
'best' course of action.  Act like a search engine. If you are asked information about something. 
You can perform a search to find websites and then visit the links and get the webpage's content to find your answers.

Anytime you respond to the user with text the user must enter information 
to continue the conversation. Never say things like. "Let me search for that 
for you" or "I can help with that". As you cannot continue with an action after that.
Never make up answers.  Always site your sources.

You can browse the web by opening tabs, running searches, and getting the content of the page.

IMPORTANT: The input and output data formats are JSON. Only JSON will work. 

Input format:
{  
  "input"?: "<User's message if any>",
  "ctx"?: {<Context info such as what page they are on, what time it is, etc>},
  "actionResult"?: {<ResultsHere> }// Action results from previous interactions
}

Your Output Format:
{
  "respToUser"?: "<Your response to user in markdown. Keep it simple. Your results are in a chat box.>",
  "respToUserData"?:"[{dataType: 'item|collection', data: { name:'', ...}  },...]",

  "action"?: {
    "actionId": "<ActionId>",
    "params": {<parameters for the action>}
  }, // an action w/ parameters to perform,
  "doNotWaitForUser"?: boolean, // If true, you can continue with another action without waiting for user input
}
"action" and "respToUser" are mutually exclusive. You can only have one or the other. Or neither. 
(all values are optional)

"respToUserData" and "respToUser" can be used together if you want to show the user a response and also show them some data.

"respToUserData" has the following format: 
[{dataType: 'item|collection', data: { type: 'link|note|other', name:'', link:'', description:'',   },...]


You can link to library collections and items by using the item id or collection id like so: ##item/item_id## or ##col/collection_id##

List of ActionIds and parameters:
-ActionId; params; description-

extractFromCurrentTab; {query: "<query for llm, such as summary or something specific>" } ; Get the content of the current page/tab.
extractFromURL; {url: string, query: "<query for llm, such as summary or something specific>"}; Get the HTML content of a page.
getWebSearchResults; {query: string}; Get google search results for a query.  Does not include content.
searchWikipedia; {query: string}; Search Wikipedia for a query.

listCollections;  ; List of user collections
searchLibrary; {query: string}; Search user's library for items and collections.

getItemsInCollection; {collectionId: string}; Get items in a collection.

getCurrentUserInfo; ; Get current user information.
getRecentActivity;  ; Get the current user's action history.
listAccountUsers; ; List of users in the account.

Example of Interactions:
Interaction:
user: {
  input: "summarize this page"
}
assistant: {action: {actionId: "extractFromCurrentTab"}}
system: {
  actionResult:{title: "...", textContent: "..."}
}
assistant: {respToUser: "The page is about..."}

Interaction:
user: {
  input: "What is the capital of France"
}
assistant: {action: {actionId: "getWebSearchResults", params: {query: "capital of France"}}]}
system: {
  actionResult: { items: [{title: "France - Wikipedia", link: "https://en.wikipedia.org/wiki/France"},...]}
}
assistant: {action: {actionId: "extractFromURL", params: {url: "https://en.wikipedia.org/wiki/France"}}}
system:{actionResult: {title: "France - Wikipedia", textContent: "France is a country in Europe...", siteName: "Wikipedia"}
assistant: {respToUser: "The capital of France is ..."}

System Time: ${new Date().toDateString()}, ${new Date().toTimeString()}
  `}function va(){return`
  You are an LLM AI agent performing tasks for an app named 'Kindredly' which let users create a personal library 
  of items like links, notes, etc, and sort them into collections. Users can also comment on 
  each item and share these items with people on their account. You have capabilities to search 
  within the app data, update it, aid with tasks, and interact with the user. If the app data doesn't have 
  the info you need, you can make suggestions based on the user's request.
  
  Instructions:
  Anytime you respond to the user with text the user must enter information 
  to continue the conversation. Never say things like. "Let me search for that 
  for you" or "I can help with that". As you cannot continue with an action after that.
  Never make up answers.  Always site your sources.
  
  IMPORTANT: The input and output data formats are JSON. Only JSON will work. 
  
  Input format:
  {  
    "input"?: "<User's message if any>",
    "ctx"?: {<Context info such as what page they are on, what time it is, etc>},
    "actionResult"?: {<ResultsHere> }// Action results from previous interactions
  }
  
  Your Output Format:
  {
    "respToUser"?: "<Your response to user in markdown. Keep it simple. Your results are in a chat box.>",
    "respToUserData"?:"[{dataType: 'item|collection', data: { name:'', ...}  },...]",
    "action"?: {
      "actionId": "<ActionId>",
      "params": {<parameters for the action>}
    }, // an action w/ parameters to perform,
    "doNotWaitForUser"?: boolean, // If true, you can continue with another action without waiting for user input
  }
  "action" and "respToUser" are mutually exclusive. You can only have one or the other. Or neither. 
  (all values are optional)

  "respToUserData" and "respToUser" can be used together if you want to show the user a response and also show them some data.


  You can link to library collections and items by using the item id or collection id like so: ##item/item_id## or ##col/collection_id##
  
  List of ActionIds and parameters:
  -ActionId; params; description-
  
  listCollections;  ; List of user collections
  searchLibrary; {query: string}; Search user's library for items and collections.
  
  getItemsInCollection; {collectionId: string}; Get items in a collection.
  
  getCurrentUserInfo; ; Get current user information.
  getRecentActivity;  ; Get the current user's action history.
  listAccountUsers; ; List of users in the account.
    
  Current System Time: ${new Date().toDateString()}, ${new Date().toTimeString()}
    `}const _a={name:{type:"string",description:"Name of the item. should be less than 80 characters if possible"},type:{type:"string",description:"Type of the item. col is a collection and can be used as a subcollection for other items. primary types are col, link, note, information.",options:["col","link","note","information"]},description:{type:"string",description:"A description of the item. Less than 150 characters."},tags:{type:"array",description:"Tags for the item. 1 or maybe 2 tags. General tags are better. Lowecase only and not too long (less than 20 char)"},url:{type:"string",criteria:"Not valid for collections. Can be used for notes, links, and other items.",description:"The url of the item or to a the relevant wikipedia article. Wikipedia links are very useful. Never include a link to example.com (it isn't real)."},textContent:{type:"string",criteria:"Not valid for collections or links",description:"The text within the item in markdown format. Don't put title at top. Lists should include bullets. Should be between 500 and 1000 characters if possible."}},x=class x{static buildActionMap(){return{extractfromurl:x._action_extractFromURL,extractfromcurrenttab:x._action_extractFromCurrentTab,getwebsearchresults:x._action_getWebSearchResults,searchwikipedia:x._action_searchWikipedia,listcollections:x._action_listCollections,ls:x._action_listCollections,searchlibrary:x._action_searchLibrary,searchlib:x._action_searchLibrary,getitemsincollection:x._action_getItemsInCollection,getcurrentuserinfo:x._action_getCurrentUserInfo,getrecentactivity:x._action_getRecentActivity,listusers:x._actions_listUsers,help:x._action_help,lssessions:x._action_listSessions}}static async itemSuggestGenerator(e){let{instructions:t,numItems:s,collectionDetails:n,previousItems:a}=e;if((await m.getCurrentUser()).type!=Ge.admin)throw new Error("User is not an admin");return await this._sendAIItemListCreationTaskRequest(t,s,n,a)}static async _sendAIItemListCreationTaskRequest(e,t,s,n){const a=[];if(a.push({role:"system",content:"You are an AI API that generates a list of items in JSON format (eg {items:[ITEMLIST]}) for the user based on their instructions. The item schema is "+JSON.stringify(_a)}),s!=null&&a.push({role:"user",content:"Collection details:"+JSON.stringify(s)}),n!=null&&n.length>0){let l=n.map(u=>({type:u.type,name:u.name,description:u.description,textContent:u.textContent,url:u.url,tags:u.tags}));a.push({role:"user",content:"Items that are already in the collection:"+JSON.stringify(l)})}a.push({role:"user",content:JSON.stringify({instructions:e,numItems:t||"as many as required"})});const i=JSON.stringify(a);y("AI: token count and messages: ",i.length/3,a);const o=await k.remoteRequest("/usertask/request",{taskname:"agentInteraction",data:{messages:a},maxTokens:5e3});if(y("AI: Result Message",o),!o||o.length==0)throw new Error("No response from AI");const c=o[0].message.content;return JSON.parse(c)}static async itemUpdateGenerator(e){let{instructions:t,actionId:s,itemDetails:n}=e;if((await m.getCurrentUser()).type!=Ge.admin)throw new Error("User is not an admin");return await this._sendAIItemUpdateTaskRequest(t,s,n)}static async _sendAIItemUpdateTaskRequest(e,t,s,n=null){const a=[];let o=Gs().find(p=>p.value==t);a.push({role:"system",content:"You are an AI API that improves the specified item based on the provided details. You response in json format. Your task is:"+o.instructions+". The result schema is "+JSON.stringify(o.schema)}),s!=null&&a.push({role:"user",content:"Item details:"+JSON.stringify(s)}),a.push({role:"user",content:JSON.stringify({instructions:e})});const c=JSON.stringify(a);y("AI: token count and messages: ",c.length/3,a),y("AI:allMessages ",c);const l=await k.remoteRequest("/usertask/request",{taskname:"agentInteraction",data:{messages:a},maxTokens:5e3});if(y("AI: Result Message",l),!l||l.length==0)throw new Error("No response from AI");const u=l[0].message.content;return JSON.parse(u)}static async aiChatRequest(e){const t="http://localhost:8000/v1",s="/chat/completions",n="POST",i={messages:[{role:"system",content:"You are a helpful assistant."},...e]};y("Chat request",i);const c=await(await fetch(`${t}${s}`,{method:n,mode:"cors",cache:"no-cache",credentials:"same-origin",headers:{accept:"application/json","Content-Type":"application/json"},redirect:"follow",referrerPolicy:"no-referrer",body:JSON.stringify(i)})).json();return y("Chat results",c),{defaultChoice:c.choices[0],results:c}}static async receivePageMessage(e,t){(e==null?void 0:e.type)=="PAGE_CONTENT"}static async openNewTab(e){return await chrome.tabs.create({url:e,active:!1})}static async getSessionById(e){return(await z("aiSessions")||{})[e]}static async getCurrentSessionId(){return await z("aiCurrentSession")||null}static async setCurrentSessionId(e){await W("aiCurrentSession",e)}static async getSessionList(e){const t=await z("aiSessions")||{};return console.log("Session list",t),Object.values(t).map(s=>({id:s.id,step:s.step}))}static async updateSession(e){const t=await z("aiSessions")||{};t[e.id]=e,await W("aiSessions",t)}static async updateSessionConn(e,t){const s=await z("aiSessionConn")||{};s[e]=t,await W("aiSessionConn",s)}static async getSessionConn(e){return(await z("aiSessionConn")||{})[e]}static async textRequest(e){let t=[];t.push({role:"system",content:"You are an AI API that provides results given the user instructions. Your response should be in json format with the following schema:"+JSON.stringify(e.schema)}),e.context!=null&&t.push({role:"user",content:e.instructions+"Context:"+JSON.stringify(e.context)});const s=JSON.stringify(t);y("AI: token count and messages: ",s.length/3,t),y("AI:allMessages ",s);const n=await k.remoteRequest("/usertask/request",{taskname:"agentInteraction",data:{messages:t},maxTokens:5e3});if(y("AI: Result Message",n),!n||n.length==0)throw new Error("No response from AI");const a=n[0].message.content;return JSON.parse(a)}static async userRequest(e,t){var l,u,p,d,f;y("AI: Processing userRequest for ",e,t);let s=e.sessionId;if(!s){s="AIS"+Date.now();const g=x.newSession(s);await x.updateSession(g)}const n=((u=(l=t==null?void 0:t.sender)==null?void 0:l.tab)==null?void 0:u.url)||(e==null?void 0:e.pageURL);let a=e.messageData.addedContext||{},i={};E.browser_mode?i={tabId:0,pageUrl:n,mode:"browser",addedContext:a}:i={tabId:(d=(p=t==null?void 0:t.sender)==null?void 0:p.tab)==null?void 0:d.id,pageUrl:n,mode:"extension",addedContext:a},await x.updateSessionConn(s,i);const o=await x.getSessionById(s);let c=(f=e.messageData.message)==null?void 0:f.charAt(0);if(["!","/","\\"].includes(c)){const g={id:e.messageData.id,type:"userCommand",data:{message:e.messageData.message,ctx:i},done:!1};return await x.runCommand(o,g),{sessionId:s}}else{const g={id:e.messageData.id,type:"userMessage",data:{message:e.messageData.message,ctx:i},done:!1};return await x.runAgent(o,g),{sessionId:s}}}static newSession(e){return{id:e,response:null,history:[],done:!1,step:0}}static async sendMessageToClients(e,t){const s=await x.getSessionConn(e.id);y("AI: Sending message to clients",t,s);const n=s==null?void 0:s.tabId;await x._sendMessageToClient(n,t)}static async _sendMessageToClient(e,t){if(E.browser_mode){const s=new CustomEvent("AGENT_MESSAGE_TO_CLIENT",{detail:t});document.dispatchEvent(s)}else await chrome.tabs.sendMessage(e,{type:"AGENT_MESSAGE_TO_CLIENT",content:t})}static async runCommand(e,t){const s=t.data.message;t.data.ctx;try{const n=s.split(" "),a=n[0].substring(1),o=n.slice(1).reduce((d,f)=>{const g=f.split("=");return d[g[0]]=g[1],d},{});console.log("AI: Processing command",a,o);let l=await x.getActionFunction(a)(e,o),u="",p=null;l&&typeof l=="string"?u=l:(u=JSON.stringify(l),p=JSON.stringify(l)),await x.sendMessageToClients(e,{messageData:p,id:""+Date.now()+"_s",role:"system"})}catch{await x.sendMessageToClients(e,{message:"Command not found. try !help",id:""+Date.now()+"_s",role:"system"})}}static async runAgent(e,t){y("AI: Processing runAgent for ",t);let s=!0,n=0;for(;s;){n+=1;let a=await x._processInput(e,t);e.step+=1,await x.updateSession(e),t=a,(t.done||n>8)&&(s=!1)}}static async _action_listSessions(e,t){const s=await z("aiSessions");return Object.keys(s)}static async _action_help(e,t){return"<b>Help - commands:</b><br/>  "+Object.keys(x.actionMap).join(" <br/>")}static async _action_searchWikipedia(e,t){var c;if(!(t!=null&&t.query))throw new Error("No query provided");var s="https://en.wikipedia.org/w/api.php",n={action:"query",list:"search",srsearch:t==null?void 0:t.query,format:"json",rslimit:5};let a=Object.keys(n).map(l=>l+"="+encodeURIComponent(n[l])),o=await(await fetch(`${s}?${a.join("&")}`)).json();return!((c=o==null?void 0:o.query)!=null&&c.search)||o.query.search.length==0?{results:[]}:o.query.search.map(l=>({title:l.title,url:`https://en.wikipedia.org/wiki/${l.title.replace(/ /g,"_")}`,snippet:l.snippet}))}static async _action_listCollections(e,t){return(await v.collectionListByUser({})).map(n=>({id:n.itemId,name:n.details.name}))}static async _action_searchLibrary(e,t){const s=await L.searchMain({searchType:"text",searchLookupValue:t.query});return kt(s).map(n=>({id:n._id,name:n.name,type:n.type,subType:n.subType,url:n.url,description:n.description}))}static async _action_getWebSearchResults(e,t){await x.sendMessageToClients(e,{message:"Performing a web search in a new tab.",id:""+Date.now()+"_s",role:"progress_update"});const s=t==null?void 0:t.query,n=await x.openNewTab("https://www.google.com/search?q="+s);y("AI: Processing action waiting for message from tab");const a=await Jt("AGENT_READY",n.id);y("AI: Processing action Agent Ready result:",a);const i=await chrome.tabs.sendMessage(n.id,{type:"AGENT_GET_CONTENT"});console.log("AI: Processing action data",i);const o=await Ca(i.html);return y("AI: Processing Page result:",o),await x.sendMessageToClients(e,{message:"Reading results.",id:""+Date.now()+"_s",role:"progress_update"}),o}static async _action_getItemsInCollection(e,t){const s=t.collectionId,n=await v.collectionItems({collectionId:s});return kt(n).map(a=>{var i;return{id:a._id,name:a.name,type:a.type,subType:a.subType,url:a.url,description:a.description,textContent:(i=a==null?void 0:a.info)==null?void 0:i.value}})}static async _action_getRecentActivity(e,t){let{userActivity:s,count:n}=await b.listUserActivity({options:{perPage:30,currentPage:0}});return{browseHistory:s.map(i=>({url:i.url,createdAt:i.createdAt}))}}static async _action_getCurrentUserInfo(e,t){const s=await m.getCurrentUser();return{userId:s._id,username:s.username,displayedName:s.displayedName,type:s.type}}static async _actions_listUsers(e,t){return(await m.listAccountUsers()).map(n=>({userId:n._id,username:n.username,displayedName:n.displayedName,type:n.type}))}static async _action_extractFromURL(e,t){await x.sendMessageToClients(e,{message:"Extracting from URL: "+(t==null?void 0:t.url),id:""+Date.now()+"_s",role:"progress_update"});const s=t==null?void 0:t.url,n=await x.openNewTab(s);y("AI: Processing action waiting for message from tab");const a=await Jt("AGENT_READY",n.id);y("AI: Processing action Agent Ready result:",a);const i=await chrome.tabs.sendMessage(n.id,{type:"AGENT_GET_CONTENT"});return await x.processLargeWebContent(i,e,t)}static async _action_extractFromCurrentTab(e,t){const s=await x.getSessionConn(e.id),n=s==null?void 0:s.tabId;if(!n)throw new Error("No tabId found in session");const a=await chrome.tabs.sendMessage(n,{type:"AGENT_GET_CONTENT"});return y("AI: Processing Page result:",a),await x.processLargeWebContent(a,e,t)}static cleanUpText(e){return e&&(e=e.replace(/[\n\r]/g," "),e=e.replace(/\s+/g," "),e)}static async processLargeWebContent(e,t,s){var f;if(!(e!=null&&e.readablePage))return await x.sendMessageToClients(t,{message:"Error Occurred, Page not loaded",id:""+Date.now()+"_s",role:"progress_update"}),null;const n=e.readablePage;let{textContent:a,siteName:i,title:o}=n,c=x.cleanUpText(a);o=x.cleanUpText(o),c&&c.length>12e3&&(await x.sendMessageToClients(t,{message:"This page is too large for me to read entirely.  I will read what I can.",id:""+Date.now()+"_s",role:"progress_update"}),c=c.substring(0,12e3),o&&(o=o.substring(0,200))),i=x.cleanUpText(i),i&&(i=i.substring(0,200));let l=!0,u=null,p=0,d=null;for(;l;)try{return u=await x.extractFromContent(t,"Extract: "+s.query||"summary from the following content",{title:o,siteName:i,textContent:c},d),{url:e.url,extractedData:(f=u==null?void 0:u.responseMessage)==null?void 0:f.extractedResults,siteName:i,title:o}}catch(g){d="Error: "+g.message+" Please fix. Your response was: "+(u==null?void 0:u.rawResponse),console.error("AI: Error processing large content",d),p+=1,p>3&&(l=!1)}return{url:e.url,textContent:a.substring(0,1e3),siteName:i,title:o}}static getActionFunction(e){let t=x.actionMap[e];return t||(t=x.actionMap[e.toLocaleLowerCase()]),t}static async _processAction(e,t,s){y("AI: Processing Action:",t,s);try{return await x.getActionFunction(t)(e,s)}catch(n){return console.error(n),await x.sendMessageToClients(e,{message:"Error Occurred "+n.message,id:""+Date.now()+"_s",role:"progress_update"}),null}}static async _processResponse(e,t,s){var o,c,l;const n=t.responseMsg;let a=!1,i=""+Date.now()+"_s";if(n.respToUser&&((o=n==null?void 0:n.action)!=null&&o.actionId)&&(n.respToUser=null),(!n.respToUser&&!((c=n==null?void 0:n.action)!=null&&c.actionId)||n.respToUser&&!(n!=null&&n.doNotWaitForUser))&&(a=!0),a&&s.type=="done")return{id:i,type:"done",done:!0};if(n.respToUser||n.respToUserData)await x.sendMessageToClients(e,{message:n.respToUser,messageData:n.respToUserData,id:t.id,role:"assistant"}),a=!0;else if((l=n==null?void 0:n.action)!=null&&l.actionId){let u=n.action;const p=await x._processAction(e,u.actionId,u.params);let d=p;return y("AI: Action results:",p),{id:i,type:"actionResult",data:{actionResult:d},done:!1}}return{id:i,type:"done",done:a}}static async _processInput(e,t){let s=!1,n=null,a=null,i=0,o=null,c=null,l=null;for(;!s&&i<4;){i+=1;try{if(!(t.type=="userMessage"&&t.data.message.startsWith("/"))){let u=await x.sendAIRequest(e,t,a);n=u.responseMessage,c=u.rawResponse,o={id:""+Date.now()+"_s",responseMsg:n,srcId:"AI",srcType:"aiResponse"}}}catch(u){a="Error: JSON Parse failed. Please fix. Your response was: "+c,console.error(a,u),n=null;continue}try{l=await x._processResponse(e,o,t),s=!0}catch(u){a="Error: Action failed. Please update your response.  Error Message: "+u.message+" Your response was"+c,console.error(a,u),n=null;continue}}return e.history.push({response:e.response,input:t}),e.response=o,l}static async _agentInputToMessage(e){if(e.type=="userMessage"){const t={input:e.data.message,ctx:e.data.ctx};return{role:"user",content:JSON.stringify(t)}}else if(e.type=="actionResult"){const t={actionResult:e.data.actionResult};return{role:"system",content:JSON.stringify(t)}}else{if(e.type=="error")return{role:"system",content:"Error"};if(e.type=="done")return{role:"system",content:"Done"}}}static async _agentResponseToMessage(e){return{role:"assistant",content:JSON.stringify(e.responseMsg)}}static async sendAIRequest(e,t,s){const n=[],a=await m.getCurrentUser();let i="";a.type==Ge.restricted&&(i=`

Below is your personality and name:
You are a cat named Whiskers. 
      You are 2 human years old, love kitty treats, and love to read.  You like to play and tell stories and poems.  You also like to encourage educational activities.  You never lie. 
      You are interacting with a child so keep things appropriate at all times. You like to add emojis to your responses.`);let o=E.browser_mode||a.type==Ge.restricted?va():Da();n.push({role:"system",content:o+i});for(const d of e.history){const{response:f,input:g}=d;f&&n.push(await x._agentResponseToMessage(f)),n.push(await x._agentInputToMessage(g))}n.push(await x._agentInputToMessage(t)),s&&n.push({role:"system",content:s});const c=JSON.stringify(n);y("AI: token count and messages: ",c.length/3,n);const l=await k.remoteRequest("/usertask/request",{taskname:"agentInteraction",data:{messages:n}});if(y("AI: Result Message",l),!l||l.length==0)throw new Error("No response from AI");const u=l[0].message.content;return{responseMessage:JSON.parse(u),rawResponse:u}}static async extractFromContent(e,t,s,n=null){const a=[];a.push({role:"system",content:"You are a helpful assistant. Return your data as JSON. Like this: {extractedResults:...}. Limit your responses to 500 words or less."}),a.push({role:"system",content:t}),a.push({role:"system",content:JSON.stringify(s)}),n&&a.push({role:"system",content:n});const o=JSON.stringify(a);y("AI: Subtask token count and messages: ",o.length/4,a);const c=await k.remoteRequest("/usertask/request",{taskname:"agentInteraction",data:{messages:a}});if(y("AI: Result Message",c),!c||c.length==0)throw new Error("No response from AI");const l=c[0].message.content;return{responseMessage:JSON.parse(l),rawResponse:l}}};A(x,"actionMap",x.buildActionMap());let re=x;class Be{static async giveTempAccess(e){await(await C.getDataIndex()).urlTempIdx.updateIdx(e,!0)}static async checkIfPermitted(e,t=null){y("SITECHECK: Checking if site is permitted",e);let s=!0,n=await m.getCurrentUser();if(y("checkIfPermitted",n),n.options.whitelistingEnabled){if(!e)return y("SITECHECK:URL not specified during check "),!1;if(y("SITECHECK: looking in index for url",e),e=tt(e),s=(await(await C.getDataIndex()).urlIdx.getMatches(e)).length>0,s||(s=(await(await C.getDataIndex()).urlTempIdx.getMatches(e)).length>0),!s){y("SITECHECK: Looks like we need a content check");const a=await(await C.getDataIndex()).ctxIdx.getMatches(e);a&&a.length>0&&(y("SITECHECK: content check enabled for this url, matches",a),s=await Be.checkIfPermittedViaContent(e,a,t))}}return y("checkIfPermitted result:",s),s}static async checkIfPermittedViaContent(e,t,s=null){var a;let n=!1;if(e=tt(e),t.includes("youtube.com")){if(e.startsWith("https://www.youtube.com/shorts/"))return y("SITECHECK: YOUTUBE SHORT FOUND, rejecting"),!1;if(y("SITECHECK: YOUTUBE FOUND, checking meta data"),s||(y("SITECHECK:looking up meta"),s=await Q.getMetaByURL(e)),y("SITECHECK: printing meta",s),!s)return!1;const i=((a=s.tsExtractedInfo)==null?void 0:a.youtubeChannelIds)||[];for(const o of i){y("YT Channel id found",o,"checking if it's permitted");const c=await(await C.getDataIndex()).attributeIdx.getMatches(Pe.YOUTUBE_CHANNEL,o);if(c&&c.length>0){y("SITECHECK: CHANNEL MATCH!",c),n=!0;break}}}return n}}class La{static async getVersionInfo(){const e=await k.remoteRequest("/version",{method:"GET"});return y("serverInfo",e),e}}let Yt={};const Ma=1e4,$t=["http","https"];function Xt(r,e=Ma){const t=Yt[r],s=new Date().getTime();let n=!1;return t&&s-t<e&&(n=!0),Yt[r]=s,y("Sentry: isVisitDup",r,t,s,s-t,n),n}function ie(r,e){if(E.appType=="ios")return{allow:r,details:e}}const Qt=["localhost","127.0.0.1"];function Oa(){try{if(E.manifestType=="safari")return!0}catch(r){return console.error(r),!1}}class be{static async checkIfAllowed(e,t){return t!=null&&t.whitelistingEnabled?e.length>0:!0}static async getInjectionCode(e){let t=[];for(var s of Object.values(e))s.useInjectors&&t.push(s);return t}static shouldSkip(e,t){return!!(Oa()&&(!e||e.trim()==""))}static async processRequestsForBlocking(e,t={}){if(e.startsWith("data:"))return ie(!0);y("SENTRY: processRequestsForBlocking",e,t);const s=e?e.split(":")[0]:null,n=e?new URL(e):null;let a=null,i=t.tabId;if(s&&!$t.includes(s)||n&&Qt.includes(n==null?void 0:n.hostname)||(e.endsWith("/")&&(e=e.slice(0,-1)),e=tt(e),this.shouldSkip(e,t)))return ie(!0,a);let o=await m.getCurrentUser(),c=o==null?void 0:o.options;const l=await C.getDataIndex();let u=await l.urlIdx.getMatches(e,!0),p=!1;u.length==0&&(u=await l.ctxIdx.getMatches(e),u.length>0&&(p=!0));let d=await this.checkIfAllowed(u,c);if(d||(d=(await l.urlTempIdx.getMatches(e)).length>0),d){try{!Xt(e)&&(u.length>0||(c==null?void 0:c.logActivity)==!0)&&(l.visitIdx.appendIds(u),oe.call("/client/logVisit",{url:e,matchingItemIds:u,blocked:!1,context:t}))}catch(f){console.error(f)}return E.appType=="ios"&&(a=await be.getFilesToInject(o,l,e,t,{onComplete:!0,onLoading:!0,contentMatch:p})),ie(!0,a)}else{try{if(y("Sentry: URL not allowed. redirecting. "+e),e.startsWith("https://www.google.com/search?q=")){const f=n==null?void 0:n.searchParams.get("q");return f?Le(i,{url:Me(`/index.html#/?type=text&value=${f}`)}):Le(i,{url:Me("/index.html")}),ie(!1)}else be.blockURL(e,u,t,i)}catch(f){console.error("Sentry: ERROR BLOCKING CONTENT",f)}return ie(!1)}}static blockURL(e,t,s,n){Xt(e)||oe.call("/client/logVisit",{url:e,matchingItemIds:t,blocked:!0,context:s}),Le(n,{url:Me("/index.html#/blocked?blockedURL="+encodeURIComponent(e))})}static async processTabCreation(e,t){e.startsWith("data:")?y("SENTRY: processTabCreation","data:..."):y("SENTRY: processTabCreation")}static async getFilesToInject(e,t,s,n,a){let i=[],o=[],c=e==null?void 0:e.options;if(a.onComplete&&(y("Injectscripts on-complete",s,n),i.push("/content-script-page-snapshot.js"),i.push("/content-script-interact.js")),a.onLoading&&(c!=null&&c.codeInjectionEnabled)){y("Injectscripts on-loading",s,n),(e==null?void 0:e.type)=="restricted"&&i.push("/content-script-event-monitor.js"),a.contentMatch&&c.whitelistingEnabled&&(i.push("/content-script-probe.js"),s.includes("youtube.com")&&(o.push("/css/youtube-restriction.css"),i.push("/content-script-youtube-restriction.js")));let l=await t.pluginIdx.getMatches(s);for(let u of l)u._id=="default-youtube-no-distractions"&&o.push("/css/youtube-distractions.css");(e==null?void 0:e.type)=="restricted"&&s.includes("reddit.com")&&(o.push("/css/reddit-distractions.css"),i.push("/content-script-reddit-distractions.js"))}return{jsFilesToInject:i,cssFilesToInject:o}}static async processRequestsForInjection(e,t={}){var c;if(e.startsWith("data:image"))return ie(!0);y("SENTRY: processRequests for injection",e,t);const s="url"in t.changeInfo||t.changeInfo.status=="loading",n=((c=t==null?void 0:t.changeInfo)==null?void 0:c.status)=="complete";if(this.shouldSkip(e,t))return ie(!0);const a=e?e.split(":")[0]:null,i=e?new URL(e):null;let o=t.tabId;if(a&&!$t.includes(a)||i&&Qt.includes(i==null?void 0:i.hostname))return ie(!0);e.endsWith("/")&&(e=e.slice(0,-1)),e=tt(e);try{let l=await m.getCurrentUser(),u=l==null?void 0:l.options;const p=await C.getDataIndex();let d=await p.urlIdx.getMatches(e,!0),f=!1;d.length==0&&(d=await p.ctxIdx.getMatches(e),d.length>0&&(f=!0));let g=await this.checkIfAllowed(d,u);if(g||(g=(await p.urlTempIdx.getMatches(e)).length>0),!g)return y("Sentry: blocked so skipping injection",e),be.blockURL(e,d,t,o),ie(!1);let{jsFilesToInject:w,cssFilesToInject:I}=await this.getFilesToInject(l,p,e,t,{onComplete:n,onLoading:s,contentMatch:f});I.length>0&&fa({target:{tabId:o},files:I}),w.length>0&&(y("Injecting JS files: ",w),ma({target:{tabId:o},files:w}))}catch(l){console.error(l)}}}const P=[];P.push({path:"/version",handler:async(r,e,t)=>await La.getVersionInfo()});P.push({path:"/client/debugInfo",handler:async(r,e,t)=>{throw new M("Not Implemented",501)}});P.push({path:"/client/dbtest",handler:async(r,e,t)=>await _e.testDB(e)});P.push({path:"/client/browser/tabs/query",handler:async(r,e,t)=>{const s=await chrome.tabs.query({});return y(" browser/tabs/query",s),s}});P.push({path:"/client/tests",handler:async(r,e,t)=>{if(e.name=="createItemAndRetrieve")return await _e.createItemAndRetrieve(e.params);if(e.name=="cryptoTest1")return await _e.cryptoTest1(e.params);if(e.name=="buildVisitHistoryIndex")return await _e.visitHistoryIndexTest(e.params);if(e.name=="getIndex")return await _e.getIndex(e.params)}});P.push({path:"/client/feedproxy",handler:async(r,e,t)=>{let s=`/userdata/proxy?type=${e.type||"xml"}&url=`+encodeURIComponent(e.url);return(await k.remoteRequestRaw(s,{},{method:"GET"})).text()}});P.push({path:"/client/fetch",handler:async(r,e,t)=>(await fetch(e.url,e.options)).text()});P.push({path:"/client/fetchFile",handler:async(r,e,t)=>{if(e.type=="image"){let n=await(await fetch(e.url)).blob();return await new Promise((i,o)=>{let c=new FileReader;c.onload=()=>i(c.result),c.onerror=o,c.readAsDataURL(n)})}else throw new M("Not Implemented",501)}});P.push({path:"/client/updateIndex",handler:async(r,e,t)=>{const s=(e==null?void 0:e.quick)!=!0;return await C.updateDataIndex(s,!0,(e==null?void 0:e.overrideIndexRebuild)==!0)}});P.push({path:"/client/hometab",handler:async(r,e,t)=>{var s,n;if(navigator.userAgent.indexOf("Firefox")!=-1){y("Opening firefox's home tab:",t);const a=(n=(s=t==null?void 0:t.sender)==null?void 0:s.tab)==null?void 0:n.id;return y("tabId",a),chrome.tabs.update(a,{url:"about:home"}),!0}else return chrome.tabs.update({url:"chrome-search://local-ntp/local-ntp.html"}),!0}});P.push({path:"/client/widgetStatus",handler:async(r,e,t)=>{let s=await m.getCurrentUserId();return await Y.get(s,"widgetStatus")||{}}});P.push({path:"/client/extension/viewInfo",handler:async(r,e,t)=>{let s=chrome.runtime.getURL("index.html");await chrome.tabs.create({url:s+"#/share?url="+e.url})}});P.push({path:"/client/ai/itemSuggestGenerator",handler:async(r,e,t)=>await re.itemSuggestGenerator(e)});P.push({path:"/client/ai/itemUpdateGenerator",handler:async(r,e,t)=>await re.itemUpdateGenerator(e)});P.push({path:"/client/ai/textRequest",handler:async(r,e,t)=>await re.textRequest(e)});P.push({path:"/client/ai/userRequest",handler:async(r,e,t)=>await re.userRequest(e,t)});P.push({path:"/client/ai/sessionList",handler:async(r,e,t)=>await re.getSessionList(e)});P.push({path:"/client/ai/getSessionById",handler:async(r,e,t)=>await re.getSessionById(e.id)});P.push({path:"/client/ai/setCurrentSessionId",handler:async(r,e,t)=>await re.setCurrentSessionId(e.id)});P.push({path:"/client/ai/getCurrentSessionId",handler:async(r,e,t)=>await re.getCurrentSessionId()});P.push({path:"/client/ai/sendPageMessage",handler:async(r,e,t)=>await re.receivePageMessage(e,t)});P.push({path:"/client/checkIfPermitted",handler:async(r,e,t)=>(y("Client Request",r,e),await Be.checkIfPermitted(e.url,e.meta))});P.push({path:"/client/sentry/processRequestsForBlocking",handler:async(r,e,t)=>(y("Sentry Request",r,e),await be.processRequestsForBlocking(e.url,e.context))});P.push({path:"/client/sentry/processRequestsForInjection",handler:async(r,e,t)=>(y("Sentry Request",r,e),await be.processRequestsForInjection(e.url,e.context))});P.push({path:"/client/userfile/getById",handler:async(r,e,t)=>await Z.getUserFileById(e,(t==null?void 0:t.includeUserFileData)==!0,(t==null?void 0:t.excludePrefix)!=!0,t==null?void 0:t.defaultPrefix)});P.push({path:"/client/userfile/upload",handler:async(r,e,t)=>await Z.uploadUserFile(e)});P.push({path:"/client/checkIfPermittedByPageContent",handler:async(r,e,t)=>{var i,o;const{sender:s}=t,n=e==null?void 0:e.url;if(n&&!n.startsWith("http"))return y("checkIfPermittedByPageContent: ignoring url",n),!0;let a=await Be.checkIfPermitted(n,e.meta);return a||(E.appType=="ios"?(y("sender tab id",(i=s==null?void 0:s.tab)==null?void 0:i.id),await Le((o=s==null?void 0:s.tab)==null?void 0:o.id,{url:Me("/index.html#/blocked?blockedURL="+encodeURIComponent(e.url))})):(y("***Website not permitted",e),await chrome.tabs.update(s.tab.id,{url:chrome.runtime.getURL("/index.html#/blocked?blockedURL="+encodeURIComponent(e.url))}))),a}});P.push({path:"/client/sentry/giveTempAccess",handler:async(r,e,t)=>await Be.giveTempAccess(e.patternList)});P.push({path:"/client/device/updateInfo",handler:async(r,e,t)=>{const s=await z("deviceRegistrationToken");return!s||s!=(e==null?void 0:e.deviceToken)?(await ae.updateDeviceToken(e.deviceToken),await W("deviceRegistrationToken",e.deviceToken),y("Device Token Updated sent to backend:",e.deviceToken)):y("Device Token not updated, same as before:",e.deviceToken),!0}});P.push({path:"/client/nativeMessage",handler:async(r,e,t)=>(await ae.sendNativeMessageViaPort({type:e.type,data:e.data}),{success:!0,message:"sent"})});P.push({path:"/client/nativeClientCheck",handler:async(r,e,t)=>({success:ae.isConnected()})});const J=[];J.push({path:"/client/encryption/getRecoveryKey",handler:async(r,e,t)=>await T.getRecoveryKey(await m.getUserRequestContext(e.userId))});J.push({path:"/client/encryption/generateRecoveryKey",handler:async(r,e,t)=>await T.generateNewRecoveryKey(await m.getUserRequestContext(e.userId))});J.push({path:"/client/encryption/saveRecoveryKeyOnServer",handler:async(r,e,t)=>await T.saveRecoveryKeyOnServer(await m.getUserRequestContext(e.userId))});J.push({path:"/client/encryption/removeRecoveryKeyFromServer",handler:async(r,e,t)=>await T.removeRecoveryKeyFromServer(await m.getUserRequestContext(e.userId))});J.push({path:"/client/encryption/recoverUsingKey",handler:async(r,e,t)=>await S.recoverUsingSecretKey(e)});J.push({path:"/client/encryption/clearCachedEncValues",handler:async(r,e,t)=>await m.clearCachedEncValues(e.userId)});J.push({path:"/client/encryption/status",handler:async(r,e,t)=>await T.encStatus(await m.getUserRequestContext(e.userId),e.force==!0)});J.push({path:"/client/encryption/enable",handler:async(r,e,t)=>{if(!await m.checkPassword(e.password,e.userId))throw console.error("Password check failed"),new M("Password does not match");y("password check successful");const n=await m.getUserRequestContext(e.userId);return await T.generateKeys(n)}});J.push({path:"/client/encryption/shareAccountKey",handler:async(r,e,t)=>e!=null&&e.userId?await S.shareAccountKeyWithUser(e.userId):await S.shareAccountKey()});J.push({path:"/client/encryption/allUserStatuses",handler:async(r,e,t)=>await S.allUserEncStatuses()});J.push({path:"/client/encryption/createAccountBackupKey",handler:async(r,e,t)=>{if(!await m.checkPassword(e.password,e.userId))throw console.error("Password check failed"),new M("Password does not match");const n=await m.getUserRequestContext(e.userId);return await T.createAccountBackupKey(n)}});J.push({path:"/client/auth/verifyPassword",handler:async(r,e,t)=>{if(!await m.checkPassword(e.password,e.userId))throw console.error("Password check failed"),new M("Password does not match")}});J.push({path:"/client/auth/setStoredPassword",handler:async(r,e,t)=>await m.setStoredPassword(e.password,e.userId)});J.push({path:"/client/auth/setStoredRecoveryKey",handler:async(r,e,t)=>await m.setStoredPassword(e.password,e.userId)});J.push({path:"/client/auth/clearStoredPassword",handler:async(r,e,t)=>await m.clearStoredPassword(e.password,e.userId)});J.push({path:"/client/encryption/encrypt",handler:async(r,e,t)=>await T.encryptData(await m.getUserRequestContext(),e)});J.push({path:"/client/encryption/decrypt",handler:async(r,e,t)=>await T.decryptData(await m.getUserRequestContext(),e.encrypted)});J.push({path:"/client/encryption/listKeys",handler:async(r,e,t)=>await T.listKeys(await m.getUserRequestContext(e.userId))});J.push({path:"/client/encryption/listKeysWithStatus",handler:async(r,e,t)=>await T.listKeysWithStatus(await m.getUserRequestContext(e.userId))});J.push({path:"/client/encryption/getKeyBackup",handler:async(r,e,t)=>await T.getKeyBackup(await m.getUserRequestContext(e.userId))});J.push({path:"/client/encryption/getKeys",handler:async(r,e,t)=>await T.getEncryptionKeys(await m.getUserRequestContext(e.userId))});async function Pa(r){return btoa(encodeURIComponent(r))}class Wa{static async createPageSnapshot(e){let{itemId:t,snapshot:s}=e;await m.getCurrentUserId();const n=await v.getItem({itemId:t});if(!n)throw new Error("No item found");if(!s)throw new Error("No snapshot data");const{styleSheetList:a,jsFileList:i,imageSrcList:o}=s,c=await Promise.all(a.map(async g=>g.href?await fetch(g.href).then(w=>w.text()):g.rules.map(w=>w.cssText).join(`
`))),l=await Promise.all(i.map(async g=>g.src?await fetch(g.src).then(w=>w.text()):g.code)),u=Object.fromEntries(await Promise.all(o.map(async g=>[g,await Ps(g,!1)])));s.jsFileData=l,s.styleSheetData=c,s.imageLookup=u,y("SNAPSHO DATA",s);const p=await Pa(JSON.stringify(s));y("SNAPSHO snapshotData",p);const d=await Z.uploadUserFile({refId:t,refType:"item",fileType:"html",encInfo:n.encInfo,filename:"snapshot",fileData:p});let f={id:"snapshot",filename:"snapshot",type:"snapshot",meta:{},fileType:"html",fileId:d};return await S.remoteRequestEncryptionWrapper("/item/attachment/add",{itemId:t,attachment:f}),d}}const U=[];U.push({path:"/client/refreshItemMeta",handler:async(r,e,t)=>{y("Refreshing item meta",e);const s=await Q.refreshItemMetaDataForItemIds(e.itemIds,e.force);return C.updateDataIndex(),s}});U.push({path:"/client/fetchDataByURL",handler:async(r,e,t)=>await Q.getDataByURL(e.url)});U.push({path:"/client/fetchMetadata",handler:async(r,e,t)=>await Q.getMetaByURL(e.url)});U.push({path:"/client/fetchMetadataAndBanner",handler:async(r,e,t)=>await Q.getMetaAndBannerByURL(e.url)});U.push({path:"/client/item/update",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/item/update",e,t)});U.push({path:"/client/item/info",handler:async(r,e,t)=>await v.getItem(e)});U.push({path:"/client/collection/listItemsWithInfoByUser",handler:async(r,e,t)=>await v.collectionItems(e)});U.push({path:"/client/collection/getItemRelInfo",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/collection/getItemRelInfo",e,t)});U.push({path:"/client/collection/itemDetails/save",handler:async(r,e,t)=>(y("Saving item details",e,{...t,dontEncrypt:e.dontEncrypt==!0}),await S.remoteRequestEncryptionWrapper("/collection/itemDetails/save",e,t))});U.push({path:"/client/item/parents/bychildid",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/item/parents/bychildid",e,t)});U.push({path:"/client/collection/encrypt",handler:async(r,e,t)=>await v.encryptCollection(e)});U.push({path:"/client/collection/decrypt",handler:async(r,e,t)=>await v.decryptCollection(e)});U.push({path:"/client/library/root",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/library/root",e,t)});U.push({path:"/item/pathtree",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper(r,e,t)});U.push({path:"/client/collection/infoByUser",handler:async(r,e,t)=>e!=null&&e.collectionId?await S.remoteRequestEncryptionWrapper("/collection/infoByUser",e,t):null});U.push({path:"/client/collection/listByUser",handler:async(r,e,t)=>await v.collectionListByUser(e)});U.push({path:"/client/collection/listByAccount",handler:async(r,e,t)=>await v.collectionListByAccount(e)});U.push({path:"/client/collection/create",handler:async(r,e,t)=>await v.createCollection(e)});U.push({path:"/client/item/save",handler:async(r,e,t)=>await v.saveItem(e,t)});U.push({path:"/client/item/similarItemsByURL",handler:async(r,e,t)=>await L.similarItemsByURL(e)});U.push({path:"/client/item/matchesForURLs",handler:async(r,e,t)=>await L.getExactMatchesForURLs(e)});U.push({path:"/client/item/matchesForPubIds",handler:async(r,e,t)=>await L.getMatchesByPublishIds(e)});U.push({path:"/client/item/getByIds",handler:async(r,e,t)=>{const{ids:s,includeAllCollections:n}=e;return await v.getUserItemsWithInfo(s,n)}});U.push({path:"/searchStatus",handler:async(r,e,t)=>(await C.getDataIndexStatus()).statusInfo()});U.push({path:"/client/item/createPageSnapshot",handler:async(r,e,t)=>await Wa.createPageSnapshot(e)});U.push({path:"/client/item/listSharedWithUser",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/item/listSharedWithUser",e,t)});U.push({path:"/client/item/listSharedByUser",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/item/listSharedByUser",e,t)});U.push({path:"/client/item/listByFilter",handler:async(r,e,t)=>await L.listItemsWithFilter(e)});U.push({path:"/client/item/listWithInfoByUser",handler:async(r,e,t)=>await v.getItemsWithInfo(e)});U.push({path:"/client/items/listWithFeedback",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/items/listWithFeedback",e,t)});U.push({path:"/client/library/rediscoverQueue",handler:async(r,e,t)=>await v.rediscoverQueue(e)});U.push({path:"/client/library/archived",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/library/archived",e,t)});U.push({path:"/client/library/hidden",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/library/hidden",e,t)});U.push({path:"/client/library/uncategorized",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/library/uncategorized",e,t)});U.push({path:"/client/searchMain",handler:async(r,e,t)=>await L.searchMain(e)});U.push({path:"/client/searchTerms",handler:async(r,e,t)=>await L.searchTerms(e)});U.push({path:"/client/searchAuto",handler:async(r,e,t)=>await L.runSearchAuto(e.searchQuery)});U.push({path:"/client/getRelatedItemsForCollection",handler:async(r,e,t)=>await L.getRelatedItemsForCollection(e.collectionId)});U.push({path:"/client/suggestCollections",handler:async(r,e,t)=>await L.runCollectionSearch(e.searchQuery)});U.push({path:"/client/collection/suggestions",handler:async(r,e,t)=>await L.getCollectionSuggestions(e.suggestionQuery,e.suggestionURL)});U.push({path:"/client/collection/recent",handler:async(r,e,t)=>await L.getCollectionsRecent()});U.push({path:"/client/searchEmbedded",handler:L.searchEmbedded});U.push({path:"/client/subscription/add",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/subscription/add",e,t)});U.push({path:"/client/subscription/edit",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/subscription/edit",e,t)});U.push({path:"/client/subscription/listForUser",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/subscription/listForUser",e,t)});U.push({path:"/client/subscription/listForRef",handler:async(r,e,t)=>await S.remoteRequestEncryptionWrapper("/subscription/listForRef",e,t)});U.push({path:"/client/visitHistoryForURLs",handler:async(r,e,t)=>await b.visitHistoryForURLs(e.urls)});U.push({path:"/client/item/attachment/add",handler:async(r,e,t)=>await v.addItemAttachment(e)});U.push({path:"/client/item/encryptItems",handler:async(r,e,t)=>await v.encryptItems(e)});U.push({path:"/client/item/decryptItems",handler:async(r,e,t)=>await v.decryptItems(e)});const he=[];he.push({path:"/client/activityMonitor/update",handler:b.update});he.push({path:"/client/activity/getUsageSince",handler:b.getUsageLogsSince});he.push({path:"/client/activity/getCurrentUsageSummary",handler:b.getCurrentUsageSummary});he.push({path:"/client/activity/clearUsageLog",handler:b.clearUsageLog});he.push({path:"/client/activity/list",handler:async(r,e,t)=>await b.listUserActivity(e)});he.push({path:"/client/logVisit",handler:async(r,e,t)=>{const s=await b.logVisit(e);return C.updateDataIndex(!1).catch(n=>{console.error("Error updating index when logging visit",n)}),s}});he.push({path:"/client/logCollectionVisit",handler:async(r,e,t)=>{const s=await b.logCollectionVisit(e);return C.updateDataIndex(!1).catch(n=>{console.error("Error updating index when logging visit",n)}),s}});class oe{static register(e,t){this.callMap[e]=t}static async call(e,t={},s={}){if("needAuth"in s&&s.needAuth&&!await H.isActive())throw console.error("Not Authenticated, not sending request to server: ",e),new M("Not Authenticated, not sending request to server",401);if(e in this.callMap){y("Making Request (local)",e,t);const n=await this.callMap[e](e,t,s);return y("Request result (local)",e,{result:n}),n}else return await k.remoteRequest(e,t,s)}}A(oe,"callMap",{});Ue.forEach(r=>oe.register(r.path,r.handler));V.forEach(r=>oe.register(r.path,r.handler));P.forEach(r=>oe.register(r.path,r.handler));J.forEach(r=>oe.register(r.path,r.handler));U.forEach(r=>oe.register(r.path,r.handler));he.forEach(r=>oe.register(r.path,r.handler));const Na=async(r,e)=>{try{if(r.type=="API_CALL")return{success:!0,result:await oe.call(r==null?void 0:r.path,r==null?void 0:r.data,{...r==null?void 0:r.options,request:r,sender:e})}}catch(t){const s=t instanceof M?t:new M(t==null?void 0:t.message);return console.error("Error is instance of ",t instanceof M,t,r==null?void 0:r.path),{success:!1,message:s.message,details:s==null?void 0:s.details,status:s==null?void 0:s.status,errorType:s==null?void 0:s.errorType}}},pr=(r,e,t)=>(Na(r,e).then(t).catch(s=>{console.error("Error in routerFunction",s);try{t({success:!1,message:s.message,details:s==null?void 0:s.details,status:s==null?void 0:s.status,errorType:s==null?void 0:s.errorType})}catch(n){console.error("Error in routerFunction",n)}}),!0);export{Na as callerFunction,pr as routerFunction};
