var m=Object.defineProperty;var w=(c,t,e)=>t in c?m(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var b=(c,t,e)=>w(c,typeof t!="symbol"?t+"":t,e);class y{constructor(t,e){b(this,"dbName");b(this,"dbVersion");b(this,"db");this.dbName=t,this.dbVersion=e,this.db=null}async open(){return new Promise((t,e)=>{const s=indexedDB.open(this.dbName,this.dbVersion);s.onerror=()=>e(s.error),s.onsuccess=()=>{this.db=s.result,t(this.db)},s.onupgradeneeded=o=>{const r=s.result;this.createObjectStore(r)}})}createObjectStore(t){t.createObjectStore("itemData",{keyPath:"id"})}async getDB(){return this.db?this.db:await this.open()}async deleteDB(){return new Promise((t,e)=>{const s=indexedDB.deleteDatabase(this.dbName);s.onerror=()=>e(s.error),s.onsuccess=()=>{this.db=null,t()}})}async close(){return new Promise((t,e)=>{this.db&&(this.db.close(),this.db=null,t())})}}class h{constructor(t,e){b(this,"idb");b(this,"tableName");this.idb=t,this.tableName=e}static async getInstance(t,e="default",s=1){const o=new y(e,s);return new h(o,t)}async get(t){const e=await this.idb.getDB();return new Promise((s,o)=>{const a=e.transaction(this.tableName,"readonly").objectStore(this.tableName).get(t);a.onerror=()=>o(a.error),a.onsuccess=()=>{a.result?s(a.result):o(new Error(`No data found for ID ${t}`))}})}async clearStore(){const e=(await this.idb.getDB()).transaction(this.tableName,"readwrite");e.objectStore(this.tableName).clear(),await new Promise((o,r)=>{e.oncomplete=()=>o(),e.onerror=()=>r(e.error)})}async deleteStore(){const t=await this.idb.getDB();try{t.deleteObjectStore(this.tableName)}catch(e){console.error(e)}}async put(t){const s=(await this.idb.getDB()).transaction(this.tableName,"readwrite"),o=s.objectStore(this.tableName);for(const r of t)o.put(r);await new Promise((r,n)=>{s.oncomplete=()=>r(),s.onerror=()=>n(s.error)})}async listAll(){const s=(await this.idb.getDB()).transaction(this.tableName,"readonly").objectStore(this.tableName);return new Promise((o,r)=>{const n=s.getAll();n.onerror=()=>{console.error("_xx error: ",n.error),r(n.error)},n.onsuccess=a=>{let i=n.result;o(i)}})}async listById(t){const o=(await this.idb.getDB()).transaction(this.tableName,"readonly").objectStore(this.tableName),r=t.map(a=>new Promise(i=>{try{const l=o.get(a);l.onsuccess=function(d){i(d.target.result)}}catch(l){console.error(l),i(void 0)}}));return await Promise.all(r).then(a=>a.filter(i=>i!==void 0))}async deleteWhereIds(t){const s=(await this.idb.getDB()).transaction(this.tableName,"readwrite"),o=s.objectStore(this.tableName);for(const r of t)o.delete(r);await new Promise((r,n)=>{s.oncomplete=()=>r(),s.onerror=()=>n(s.error)})}async listWhere(t){const o=(await this.idb.getDB()).transaction(this.tableName,"readonly").objectStore(this.tableName),r=[];return new Promise((n,a)=>{const i=o.openCursor();i.onerror=()=>a(i.error),i.onsuccess=l=>{const d=i.result;if(d){const u=JSON.parse(d.value.data);t(u)&&r.push(u),d.continue()}else n(r)}})}async getTransaction(t="readwrite"){return(await this.idb.getDB()).transaction(this.tableName,t)}async getDB(){return await this.idb.getDB()}async close(){await this.idb.close()}async getIDB(){this.idb}}export{h as I};
